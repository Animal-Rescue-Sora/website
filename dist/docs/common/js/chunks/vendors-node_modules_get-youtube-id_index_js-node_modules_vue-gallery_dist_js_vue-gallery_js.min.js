(globalThis["webpackChunkanimal_rescue_sora"] = globalThis["webpackChunkanimal_rescue_sora"] || []).push([["vendors-node_modules_get-youtube-id_index_js-node_modules_vue-gallery_dist_js_vue-gallery_js"],{

/***/ "./node_modules/blueimp-gallery/js/blueimp-gallery-fullscreen.js":
/*!***********************************************************************!*\
  !*** ./node_modules/blueimp-gallery/js/blueimp-gallery-fullscreen.js ***!
  \***********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * blueimp Gallery Fullscreen JS
 * https://github.com/blueimp/Gallery
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 */

/* global define */

;(function (factory) {
  'use strict'
  if (true) {
    // Register as an anonymous AMD module:
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./blueimp-helper */ "./node_modules/blueimp-gallery/js/blueimp-helper.js"), __webpack_require__(/*! ./blueimp-gallery */ "./node_modules/blueimp-gallery/js/blueimp-gallery.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
  } else {}
})(function ($, Gallery) {
  'use strict'

  var galleryPrototype = Gallery.prototype

  $.extend(galleryPrototype.options, {
    // Defines if the gallery should open in fullscreen mode:
    fullScreen: false
  })

  var initialize = galleryPrototype.initialize
  var close = galleryPrototype.close

  $.extend(galleryPrototype, {
    getFullScreenElement: function () {
      return (
        document.fullscreenElement ||
        document.webkitFullscreenElement ||
        document.mozFullScreenElement ||
        document.msFullscreenElement
      )
    },

    requestFullScreen: function (element) {
      if (element.requestFullscreen) {
        element.requestFullscreen()
      } else if (element.webkitRequestFullscreen) {
        element.webkitRequestFullscreen()
      } else if (element.mozRequestFullScreen) {
        element.mozRequestFullScreen()
      } else if (element.msRequestFullscreen) {
        element.msRequestFullscreen()
      }
    },

    exitFullScreen: function () {
      if (document.exitFullscreen) {
        document.exitFullscreen()
      } else if (document.webkitCancelFullScreen) {
        document.webkitCancelFullScreen()
      } else if (document.mozCancelFullScreen) {
        document.mozCancelFullScreen()
      } else if (document.msExitFullscreen) {
        document.msExitFullscreen()
      }
    },

    initialize: function () {
      initialize.call(this)
      if (this.options.fullScreen && !this.getFullScreenElement()) {
        this.requestFullScreen(this.container[0])
      }
    },

    close: function () {
      if (this.getFullScreenElement() === this.container[0]) {
        this.exitFullScreen()
      }
      close.call(this)
    }
  })

  return Gallery
})


/***/ }),

/***/ "./node_modules/blueimp-gallery/js/blueimp-gallery-video.js":
/*!******************************************************************!*\
  !*** ./node_modules/blueimp-gallery/js/blueimp-gallery-video.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * blueimp Gallery Video Factory JS
 * https://github.com/blueimp/Gallery
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 */

/* global define */

;(function (factory) {
  'use strict'
  if (true) {
    // Register as an anonymous AMD module:
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./blueimp-helper */ "./node_modules/blueimp-gallery/js/blueimp-helper.js"), __webpack_require__(/*! ./blueimp-gallery */ "./node_modules/blueimp-gallery/js/blueimp-gallery.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
  } else {}
})(function ($, Gallery) {
  'use strict'

  var galleryPrototype = Gallery.prototype

  $.extend(galleryPrototype.options, {
    // The class for video content elements:
    videoContentClass: 'video-content',
    // The class for video when it is loading:
    videoLoadingClass: 'video-loading',
    // The class for video when it is playing:
    videoPlayingClass: 'video-playing',
    // The list object property (or data attribute) for the video poster URL:
    videoPosterProperty: 'poster',
    // The list object property (or data attribute) for the video sources array:
    videoSourcesProperty: 'sources'
  })

  var handleSlide = galleryPrototype.handleSlide

  $.extend(galleryPrototype, {
    handleSlide: function (index) {
      handleSlide.call(this, index)
      if (this.playingVideo) {
        this.playingVideo.pause()
      }
    },

    videoFactory: function (obj, callback, videoInterface) {
      var that = this
      var options = this.options
      var videoContainerNode = this.elementPrototype.cloneNode(false)
      var videoContainer = $(videoContainerNode)
      var errorArgs = [
        {
          type: 'error',
          target: videoContainerNode
        }
      ]
      var video = videoInterface || document.createElement('video')
      var url = this.getItemProperty(obj, options.urlProperty)
      var type = this.getItemProperty(obj, options.typeProperty)
      var title = this.getItemProperty(obj, options.titleProperty)
      var altText =
        this.getItemProperty(obj, this.options.altTextProperty) || title
      var posterUrl = this.getItemProperty(obj, options.videoPosterProperty)
      var posterImage
      var sources = this.getItemProperty(obj, options.videoSourcesProperty)
      var source
      var playMediaControl
      var isLoading
      var hasControls
      videoContainer.addClass(options.videoContentClass)
      if (title) {
        videoContainerNode.title = title
      }
      if (video.canPlayType) {
        if (url && type && video.canPlayType(type)) {
          video.src = url
        } else if (sources) {
          while (sources.length) {
            source = sources.shift()
            url = this.getItemProperty(source, options.urlProperty)
            type = this.getItemProperty(source, options.typeProperty)
            if (url && type && video.canPlayType(type)) {
              video.src = url
              break
            }
          }
        }
      }
      if (posterUrl) {
        video.poster = posterUrl
        posterImage = this.imagePrototype.cloneNode(false)
        $(posterImage).addClass(options.toggleClass)
        posterImage.src = posterUrl
        posterImage.draggable = false
        posterImage.alt = altText
        videoContainerNode.appendChild(posterImage)
      }
      playMediaControl = document.createElement('a')
      playMediaControl.setAttribute('target', '_blank')
      if (!videoInterface) {
        playMediaControl.setAttribute('download', title)
      }
      playMediaControl.href = url
      if (video.src) {
        video.controls = true
        ;(videoInterface || $(video))
          .on('error', function () {
            that.setTimeout(callback, errorArgs)
          })
          .on('pause', function () {
            if (video.seeking) return
            isLoading = false
            videoContainer
              .removeClass(that.options.videoLoadingClass)
              .removeClass(that.options.videoPlayingClass)
            if (hasControls) {
              that.container.addClass(that.options.controlsClass)
            }
            delete that.playingVideo
            if (that.interval) {
              that.play()
            }
          })
          .on('playing', function () {
            isLoading = false
            videoContainer
              .removeClass(that.options.videoLoadingClass)
              .addClass(that.options.videoPlayingClass)
            if (that.container.hasClass(that.options.controlsClass)) {
              hasControls = true
              that.container.removeClass(that.options.controlsClass)
            } else {
              hasControls = false
            }
          })
          .on('play', function () {
            window.clearTimeout(that.timeout)
            isLoading = true
            videoContainer.addClass(that.options.videoLoadingClass)
            that.playingVideo = video
          })
        $(playMediaControl).on('click', function (event) {
          that.preventDefault(event)
          if (isLoading) {
            video.pause()
          } else {
            video.play()
          }
        })
        videoContainerNode.appendChild(
          (videoInterface && videoInterface.element) || video
        )
      }
      videoContainerNode.appendChild(playMediaControl)
      this.setTimeout(callback, [
        {
          type: 'load',
          target: videoContainerNode
        }
      ])
      return videoContainerNode
    }
  })

  return Gallery
})


/***/ }),

/***/ "./node_modules/blueimp-gallery/js/blueimp-gallery-youtube.js":
/*!********************************************************************!*\
  !*** ./node_modules/blueimp-gallery/js/blueimp-gallery-youtube.js ***!
  \********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * blueimp Gallery YouTube Video Factory JS
 * https://github.com/blueimp/Gallery
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 */

/* global define, YT */

;(function (factory) {
  'use strict'
  if (true) {
    // Register as an anonymous AMD module:
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./blueimp-helper */ "./node_modules/blueimp-gallery/js/blueimp-helper.js"), __webpack_require__(/*! ./blueimp-gallery-video */ "./node_modules/blueimp-gallery/js/blueimp-gallery-video.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
  } else {}
})(function ($, Gallery) {
  'use strict'

  if (!window.postMessage) {
    return Gallery
  }

  var galleryPrototype = Gallery.prototype

  $.extend(galleryPrototype.options, {
    // The list object property (or data attribute) with the YouTube video id:
    youTubeVideoIdProperty: 'youtube',
    // Optional object with parameters passed to the YouTube video player:
    // https://developers.google.com/youtube/player_parameters
    youTubePlayerVars: {
      wmode: 'transparent'
    },
    // Require a click on the native YouTube player for the initial playback:
    youTubeClickToPlay: true
  })

  var textFactory =
    galleryPrototype.textFactory || galleryPrototype.imageFactory
  var YouTubePlayer = function (videoId, playerVars, clickToPlay) {
    this.videoId = videoId
    this.playerVars = playerVars
    this.clickToPlay = clickToPlay
    this.element = document.createElement('div')
    this.listeners = {}
  }

  $.extend(YouTubePlayer.prototype, {
    canPlayType: function () {
      return true
    },

    on: function (type, func) {
      this.listeners[type] = func
      return this
    },

    loadAPI: function () {
      var that = this
      var onYouTubeIframeAPIReady = window.onYouTubeIframeAPIReady
      var apiUrl = '//www.youtube.com/iframe_api'
      var scriptTags = document.getElementsByTagName('script')
      var i = scriptTags.length
      var scriptTag
      window.onYouTubeIframeAPIReady = function () {
        if (onYouTubeIframeAPIReady) {
          onYouTubeIframeAPIReady.apply(this)
        }
        if (that.playOnReady) {
          that.play()
        }
      }
      while (i) {
        i -= 1
        if (scriptTags[i].src === apiUrl) {
          return
        }
      }
      scriptTag = document.createElement('script')
      scriptTag.src = apiUrl
      scriptTags[0].parentNode.insertBefore(scriptTag, scriptTags[0])
    },

    onReady: function () {
      this.ready = true
      if (this.playOnReady) {
        this.play()
      }
    },

    onPlaying: function () {
      if (this.playStatus < 2) {
        this.listeners.playing()
        this.playStatus = 2
      }
    },

    onPause: function () {
      galleryPrototype.setTimeout.call(this, this.checkSeek, null, 2000)
    },

    checkSeek: function () {
      if (
        this.stateChange === YT.PlayerState.PAUSED ||
        this.stateChange === YT.PlayerState.ENDED
      ) {
        // check if current state change is actually paused
        this.listeners.pause()
        delete this.playStatus
      }
    },

    onStateChange: function (event) {
      switch (event.data) {
        case YT.PlayerState.PLAYING:
          this.hasPlayed = true
          this.onPlaying()
          break
        case YT.PlayerState.PAUSED:
        case YT.PlayerState.ENDED:
          this.onPause()
          break
      }
      // Save most recent state change to this.stateChange
      this.stateChange = event.data
    },

    onError: function (event) {
      this.listeners.error(event)
    },

    play: function () {
      var that = this
      if (!this.playStatus) {
        this.listeners.play()
        this.playStatus = 1
      }
      if (this.ready) {
        if (
          !this.hasPlayed &&
          (this.clickToPlay ||
            (window.navigator &&
              /iP(hone|od|ad)/.test(window.navigator.platform)))
        ) {
          // Manually trigger the playing callback if clickToPlay
          // is enabled and to workaround a limitation in iOS,
          // which requires synchronous user interaction to start
          // the video playback:
          this.onPlaying()
        } else {
          this.player.playVideo()
        }
      } else {
        this.playOnReady = true
        if (!(window.YT && YT.Player)) {
          this.loadAPI()
        } else if (!this.player) {
          this.player = new YT.Player(this.element, {
            videoId: this.videoId,
            playerVars: this.playerVars,
            events: {
              onReady: function () {
                that.onReady()
              },
              onStateChange: function (event) {
                that.onStateChange(event)
              },
              onError: function (event) {
                that.onError(event)
              }
            }
          })
        }
      }
    },

    pause: function () {
      if (this.ready) {
        this.player.pauseVideo()
      } else if (this.playStatus) {
        delete this.playOnReady
        this.listeners.pause()
        delete this.playStatus
      }
    }
  })

  $.extend(galleryPrototype, {
    YouTubePlayer: YouTubePlayer,

    textFactory: function (obj, callback) {
      var options = this.options
      var videoId = this.getItemProperty(obj, options.youTubeVideoIdProperty)
      if (videoId) {
        if (this.getItemProperty(obj, options.urlProperty) === undefined) {
          obj[options.urlProperty] = '//www.youtube.com/watch?v=' + videoId
        }
        if (
          this.getItemProperty(obj, options.videoPosterProperty) === undefined
        ) {
          obj[options.videoPosterProperty] =
            '//img.youtube.com/vi/' + videoId + '/maxresdefault.jpg'
        }
        return this.videoFactory(
          obj,
          callback,
          new YouTubePlayer(
            videoId,
            options.youTubePlayerVars,
            options.youTubeClickToPlay
          )
        )
      }
      return textFactory.call(this, obj, callback)
    }
  })

  return Gallery
})


/***/ }),

/***/ "./node_modules/blueimp-gallery/js/blueimp-gallery.js":
/*!************************************************************!*\
  !*** ./node_modules/blueimp-gallery/js/blueimp-gallery.js ***!
  \************************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * blueimp Gallery JS
 * https://github.com/blueimp/Gallery
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Swipe implementation based on
 * https://github.com/bradbirdsall/Swipe
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 */

/* global define, DocumentTouch */

/* eslint-disable no-param-reassign */

;(function (factory) {
  'use strict'
  if (true) {
    // Register as an anonymous AMD module:
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./blueimp-helper */ "./node_modules/blueimp-gallery/js/blueimp-helper.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
  } else {}
})(function ($) {
  'use strict'

  /**
   * Gallery constructor
   *
   * @class
   * @param {Array|NodeList} list Gallery content
   * @param {object} [options] Gallery options
   * @returns {object} Gallery object
   */
  function Gallery(list, options) {
    if (document.body.style.maxHeight === undefined) {
      // document.body.style.maxHeight is undefined on IE6 and lower
      return null
    }
    if (!this || this.options !== Gallery.prototype.options) {
      // Called as function instead of as constructor,
      // so we simply return a new instance:
      return new Gallery(list, options)
    }
    if (!list || !list.length) {
      this.console.log(
        'blueimp Gallery: No or empty list provided as first argument.',
        list
      )
      return
    }
    this.list = list
    this.num = list.length
    this.initOptions(options)
    this.initialize()
  }

  $.extend(Gallery.prototype, {
    options: {
      // The Id, element or querySelector of the gallery widget:
      container: '#blueimp-gallery',
      // The tag name, Id, element or querySelector of the slides container:
      slidesContainer: 'div',
      // The tag name, Id, element or querySelector of the title element:
      titleElement: 'h3',
      // The class to add when the gallery is visible:
      displayClass: 'blueimp-gallery-display',
      // The class to add when the gallery controls are visible:
      controlsClass: 'blueimp-gallery-controls',
      // The class to add when the gallery only displays one element:
      singleClass: 'blueimp-gallery-single',
      // The class to add when the left edge has been reached:
      leftEdgeClass: 'blueimp-gallery-left',
      // The class to add when the right edge has been reached:
      rightEdgeClass: 'blueimp-gallery-right',
      // The class to add when the automatic slideshow is active:
      playingClass: 'blueimp-gallery-playing',
      // The class for all slides:
      slideClass: 'slide',
      // The slide class for loading elements:
      slideLoadingClass: 'slide-loading',
      // The slide class for elements that failed to load:
      slideErrorClass: 'slide-error',
      // The class for the content element loaded into each slide:
      slideContentClass: 'slide-content',
      // The class for the "toggle" control:
      toggleClass: 'toggle',
      // The class for the "prev" control:
      prevClass: 'prev',
      // The class for the "next" control:
      nextClass: 'next',
      // The class for the "close" control:
      closeClass: 'close',
      // The class for the "play-pause" toggle control:
      playPauseClass: 'play-pause',
      // The list object property (or data attribute) with the object type:
      typeProperty: 'type',
      // The list object property (or data attribute) with the object title:
      titleProperty: 'title',
      // The list object property (or data attribute) with the object alt text:
      altTextProperty: 'alt',
      // The list object property (or data attribute) with the object URL:
      urlProperty: 'href',
      // The list object property (or data attribute) with the object srcset URL(s):
      srcsetProperty: 'urlset',
      // The gallery listens for transitionend events before triggering the
      // opened and closed events, unless the following option is set to false:
      displayTransition: true,
      // Defines if the gallery slides are cleared from the gallery modal,
      // or reused for the next gallery initialization:
      clearSlides: true,
      // Defines if images should be stretched to fill the available space,
      // while maintaining their aspect ratio (will only be enabled for browsers
      // supporting background-size="contain", which excludes IE < 9).
      // Set to "cover", to make images cover all available space (requires
      // support for background-size="cover", which excludes IE < 9):
      stretchImages: false,
      // Toggle the controls on pressing the Return key:
      toggleControlsOnReturn: true,
      // Toggle the controls on slide click:
      toggleControlsOnSlideClick: true,
      // Toggle the automatic slideshow interval on pressing the Space key:
      toggleSlideshowOnSpace: true,
      // Navigate the gallery by pressing left and right on the keyboard:
      enableKeyboardNavigation: true,
      // Close the gallery on pressing the Esc key:
      closeOnEscape: true,
      // Close the gallery when clicking on an empty slide area:
      closeOnSlideClick: true,
      // Close the gallery by swiping up or down:
      closeOnSwipeUpOrDown: true,
      // Close the gallery when URL changes:
      closeOnHashChange: true,
      // Emulate touch events on mouse-pointer devices such as desktop browsers:
      emulateTouchEvents: true,
      // Stop touch events from bubbling up to ancestor elements of the Gallery:
      stopTouchEventsPropagation: false,
      // Hide the page scrollbars:
      hidePageScrollbars: true,
      // Stops any touches on the container from scrolling the page:
      disableScroll: true,
      // Carousel mode (shortcut for carousel specific options):
      carousel: false,
      // Allow continuous navigation, moving from last to first
      // and from first to last slide:
      continuous: true,
      // Remove elements outside of the preload range from the DOM:
      unloadElements: true,
      // Start with the automatic slideshow:
      startSlideshow: false,
      // Delay in milliseconds between slides for the automatic slideshow:
      slideshowInterval: 5000,
      // The direction the slides are moving: ltr=LeftToRight or rtl=RightToLeft
      slideshowDirection: 'ltr',
      // The starting index as integer.
      // Can also be an object of the given list,
      // or an equal object with the same url property:
      index: 0,
      // The number of elements to load around the current index:
      preloadRange: 2,
      // The transition duration between slide changes in milliseconds:
      transitionDuration: 300,
      // The transition duration for automatic slide changes, set to an integer
      // greater 0 to override the default transition duration:
      slideshowTransitionDuration: 500,
      // The event object for which the default action will be canceled
      // on Gallery initialization (e.g. the click event to open the Gallery):
      event: undefined,
      // Callback function executed when the Gallery is initialized.
      // Is called with the gallery instance as "this" object:
      onopen: undefined,
      // Callback function executed when the Gallery has been initialized
      // and the initialization transition has been completed.
      // Is called with the gallery instance as "this" object:
      onopened: undefined,
      // Callback function executed on slide change.
      // Is called with the gallery instance as "this" object and the
      // current index and slide as arguments:
      onslide: undefined,
      // Callback function executed after the slide change transition.
      // Is called with the gallery instance as "this" object and the
      // current index and slide as arguments:
      onslideend: undefined,
      // Callback function executed on slide content load.
      // Is called with the gallery instance as "this" object and the
      // slide index and slide element as arguments:
      onslidecomplete: undefined,
      // Callback function executed when the Gallery is about to be closed.
      // Is called with the gallery instance as "this" object:
      onclose: undefined,
      // Callback function executed when the Gallery has been closed
      // and the closing transition has been completed.
      // Is called with the gallery instance as "this" object:
      onclosed: undefined
    },

    carouselOptions: {
      hidePageScrollbars: false,
      toggleControlsOnReturn: false,
      toggleSlideshowOnSpace: false,
      enableKeyboardNavigation: false,
      closeOnEscape: false,
      closeOnSlideClick: false,
      closeOnSwipeUpOrDown: false,
      disableScroll: false,
      startSlideshow: true
    },

    console:
      window.console && typeof window.console.log === 'function'
        ? window.console
        : { log: function () {} },

    // Detect touch, transition, transform and background-size support:
    support: (function (element) {
      var support = {
        touch:
          window.ontouchstart !== undefined ||
          (window.DocumentTouch && document instanceof DocumentTouch)
      }
      var transitions = {
        webkitTransition: {
          end: 'webkitTransitionEnd',
          prefix: '-webkit-'
        },
        MozTransition: {
          end: 'transitionend',
          prefix: '-moz-'
        },
        OTransition: {
          end: 'otransitionend',
          prefix: '-o-'
        },
        transition: {
          end: 'transitionend',
          prefix: ''
        }
      }
      var prop
      for (prop in transitions) {
        if (
          Object.prototype.hasOwnProperty.call(transitions, prop) &&
          element.style[prop] !== undefined
        ) {
          support.transition = transitions[prop]
          support.transition.name = prop
          break
        }
      }
      /**
       * Tests browser support
       */
      function elementTests() {
        var transition = support.transition
        var prop
        var translateZ
        document.body.appendChild(element)
        if (transition) {
          prop = transition.name.slice(0, -9) + 'ransform'
          if (element.style[prop] !== undefined) {
            element.style[prop] = 'translateZ(0)'
            translateZ = window
              .getComputedStyle(element)
              .getPropertyValue(transition.prefix + 'transform')
            support.transform = {
              prefix: transition.prefix,
              name: prop,
              translate: true,
              translateZ: !!translateZ && translateZ !== 'none'
            }
          }
        }
        if (element.style.backgroundSize !== undefined) {
          support.backgroundSize = {}
          element.style.backgroundSize = 'contain'
          support.backgroundSize.contain =
            window
              .getComputedStyle(element)
              .getPropertyValue('background-size') === 'contain'
          element.style.backgroundSize = 'cover'
          support.backgroundSize.cover =
            window
              .getComputedStyle(element)
              .getPropertyValue('background-size') === 'cover'
        }
        document.body.removeChild(element)
      }
      if (document.body) {
        elementTests()
      } else {
        $(document).on('DOMContentLoaded', elementTests)
      }
      return support
      // Test element, has to be standard HTML and must not be hidden
      // for the CSS3 tests using window.getComputedStyle to be applicable:
    })(document.createElement('div')),

    requestAnimationFrame:
      window.requestAnimationFrame ||
      window.webkitRequestAnimationFrame ||
      window.mozRequestAnimationFrame,

    cancelAnimationFrame:
      window.cancelAnimationFrame ||
      window.webkitCancelRequestAnimationFrame ||
      window.webkitCancelAnimationFrame ||
      window.mozCancelAnimationFrame,

    initialize: function () {
      this.initStartIndex()
      if (this.initWidget() === false) {
        return false
      }
      this.initEventListeners()
      // Load the slide at the given index:
      this.onslide(this.index)
      // Manually trigger the slideend event for the initial slide:
      this.ontransitionend()
      // Start the automatic slideshow if applicable:
      if (this.options.startSlideshow) {
        this.play()
      }
    },

    slide: function (to, duration) {
      window.clearTimeout(this.timeout)
      var index = this.index
      var direction
      var naturalDirection
      var diff
      if (index === to || this.num === 1) {
        return
      }
      if (!duration) {
        duration = this.options.transitionDuration
      }
      if (this.support.transform) {
        if (!this.options.continuous) {
          to = this.circle(to)
        }
        // 1: backward, -1: forward:
        direction = Math.abs(index - to) / (index - to)
        // Get the actual position of the slide:
        if (this.options.continuous) {
          naturalDirection = direction
          direction = -this.positions[this.circle(to)] / this.slideWidth
          // If going forward but to < index, use to = slides.length + to
          // If going backward but to > index, use to = -slides.length + to
          if (direction !== naturalDirection) {
            to = -direction * this.num + to
          }
        }
        diff = Math.abs(index - to) - 1
        // Move all the slides between index and to in the right direction:
        while (diff) {
          diff -= 1
          this.move(
            this.circle((to > index ? to : index) - diff - 1),
            this.slideWidth * direction,
            0
          )
        }
        to = this.circle(to)
        this.move(index, this.slideWidth * direction, duration)
        this.move(to, 0, duration)
        if (this.options.continuous) {
          this.move(
            this.circle(to - direction),
            -(this.slideWidth * direction),
            0
          )
        }
      } else {
        to = this.circle(to)
        this.animate(index * -this.slideWidth, to * -this.slideWidth, duration)
      }
      this.onslide(to)
    },

    getIndex: function () {
      return this.index
    },

    getNumber: function () {
      return this.num
    },

    prev: function () {
      if (this.options.continuous || this.index) {
        this.slide(this.index - 1)
      }
    },

    next: function () {
      if (this.options.continuous || this.index < this.num - 1) {
        this.slide(this.index + 1)
      }
    },

    play: function (time) {
      var that = this
      var nextIndex =
        this.index + (this.options.slideshowDirection === 'rtl' ? -1 : 1)
      window.clearTimeout(this.timeout)
      this.interval = time || this.options.slideshowInterval
      if (this.elements[this.index] > 1) {
        this.timeout = this.setTimeout(
          (!this.requestAnimationFrame && this.slide) ||
            function (to, duration) {
              that.animationFrameId = that.requestAnimationFrame.call(
                window,
                function () {
                  that.slide(to, duration)
                }
              )
            },
          [nextIndex, this.options.slideshowTransitionDuration],
          this.interval
        )
      }
      this.container.addClass(this.options.playingClass)
    },

    pause: function () {
      window.clearTimeout(this.timeout)
      this.interval = null
      if (this.cancelAnimationFrame) {
        this.cancelAnimationFrame.call(window, this.animationFrameId)
        this.animationFrameId = null
      }
      this.container.removeClass(this.options.playingClass)
    },

    add: function (list) {
      var i
      if (!list.concat) {
        // Make a real array out of the list to add:
        list = Array.prototype.slice.call(list)
      }
      if (!this.list.concat) {
        // Make a real array out of the Gallery list:
        this.list = Array.prototype.slice.call(this.list)
      }
      this.list = this.list.concat(list)
      this.num = this.list.length
      if (this.num > 2 && this.options.continuous === null) {
        this.options.continuous = true
        this.container.removeClass(this.options.leftEdgeClass)
      }
      this.container
        .removeClass(this.options.rightEdgeClass)
        .removeClass(this.options.singleClass)
      for (i = this.num - list.length; i < this.num; i += 1) {
        this.addSlide(i)
        this.positionSlide(i)
      }
      this.positions.length = this.num
      this.initSlides(true)
    },

    resetSlides: function () {
      this.slidesContainer.empty()
      this.unloadAllSlides()
      this.slides = []
    },

    handleClose: function () {
      var options = this.options
      this.destroyEventListeners()
      // Cancel the slideshow:
      this.pause()
      this.container[0].style.display = 'none'
      this.container
        .removeClass(options.displayClass)
        .removeClass(options.singleClass)
        .removeClass(options.leftEdgeClass)
        .removeClass(options.rightEdgeClass)
      if (options.hidePageScrollbars) {
        document.body.style.overflow = this.bodyOverflowStyle
      }
      if (this.options.clearSlides) {
        this.resetSlides()
      }
      if (this.options.onclosed) {
        this.options.onclosed.call(this)
      }
    },

    close: function () {
      var that = this
      /**
       * Close handler
       *
       * @param {event} event Close event
       */
      function closeHandler(event) {
        if (event.target === that.container[0]) {
          that.container.off(that.support.transition.end, closeHandler)
          that.handleClose()
        }
      }
      if (this.options.onclose) {
        this.options.onclose.call(this)
      }
      if (this.support.transition && this.options.displayTransition) {
        this.container.on(this.support.transition.end, closeHandler)
        this.container.removeClass(this.options.displayClass)
      } else {
        this.handleClose()
      }
    },

    circle: function (index) {
      // Always return a number inside of the slides index range:
      return (this.num + (index % this.num)) % this.num
    },

    move: function (index, dist, duration) {
      this.translateX(index, dist, duration)
      this.positions[index] = dist
    },

    translate: function (index, x, y, duration) {
      if (!this.slides[index]) return
      var style = this.slides[index].style
      var transition = this.support.transition
      var transform = this.support.transform
      style[transition.name + 'Duration'] = duration + 'ms'
      style[transform.name] =
        'translate(' +
        x +
        'px, ' +
        y +
        'px)' +
        (transform.translateZ ? ' translateZ(0)' : '')
    },

    translateX: function (index, x, duration) {
      this.translate(index, x, 0, duration)
    },

    translateY: function (index, y, duration) {
      this.translate(index, 0, y, duration)
    },

    animate: function (from, to, duration) {
      if (!duration) {
        this.slidesContainer[0].style.left = to + 'px'
        return
      }
      var that = this
      var start = new Date().getTime()
      var timer = window.setInterval(function () {
        var timeElap = new Date().getTime() - start
        if (timeElap > duration) {
          that.slidesContainer[0].style.left = to + 'px'
          that.ontransitionend()
          window.clearInterval(timer)
          return
        }
        that.slidesContainer[0].style.left =
          (to - from) * (Math.floor((timeElap / duration) * 100) / 100) +
          from +
          'px'
      }, 4)
    },

    preventDefault: function (event) {
      if (event.preventDefault) {
        event.preventDefault()
      } else {
        event.returnValue = false
      }
    },

    stopPropagation: function (event) {
      if (event.stopPropagation) {
        event.stopPropagation()
      } else {
        event.cancelBubble = true
      }
    },

    onresize: function () {
      this.initSlides(true)
    },

    onhashchange: function () {
      if (this.options.closeOnHashChange) {
        this.close()
      }
    },

    onmousedown: function (event) {
      // Trigger on clicks of the left mouse button only
      // and exclude video & audio elements:
      if (
        event.which &&
        event.which === 1 &&
        event.target.nodeName !== 'VIDEO' &&
        event.target.nodeName !== 'AUDIO'
      ) {
        // Preventing the default mousedown action is required
        // to make touch emulation work with Firefox:
        event.preventDefault()
        ;(event.originalEvent || event).touches = [
          {
            pageX: event.pageX,
            pageY: event.pageY
          }
        ]
        this.ontouchstart(event)
      }
    },

    onmousemove: function (event) {
      if (this.touchStart) {
        ;(event.originalEvent || event).touches = [
          {
            pageX: event.pageX,
            pageY: event.pageY
          }
        ]
        this.ontouchmove(event)
      }
    },

    onmouseup: function (event) {
      if (this.touchStart) {
        this.ontouchend(event)
        delete this.touchStart
      }
    },

    onmouseout: function (event) {
      if (this.touchStart) {
        var target = event.target
        var related = event.relatedTarget
        if (!related || (related !== target && !$.contains(target, related))) {
          this.onmouseup(event)
        }
      }
    },

    ontouchstart: function (event) {
      if (this.options.stopTouchEventsPropagation) {
        this.stopPropagation(event)
      }
      // jQuery doesn't copy touch event properties by default,
      // so we have to access the originalEvent object:
      var touch = (event.originalEvent || event).touches[0]
      this.touchStart = {
        // Remember the initial touch coordinates:
        x: touch.pageX,
        y: touch.pageY,
        // Store the time to determine touch duration:
        time: Date.now()
      }
      // Helper variable to detect scroll movement:
      this.isScrolling = undefined
      // Reset delta values:
      this.touchDelta = {}
    },

    ontouchmove: function (event) {
      if (this.options.stopTouchEventsPropagation) {
        this.stopPropagation(event)
      }
      // jQuery doesn't copy touch event properties by default,
      // so we have to access the originalEvent object:
      var touches = (event.originalEvent || event).touches
      var touch = touches[0]
      var scale = (event.originalEvent || event).scale
      var index = this.index
      var touchDeltaX
      var indices
      // Ensure this is a one touch swipe and not, e.g. a pinch:
      if (touches.length > 1 || (scale && scale !== 1)) {
        return
      }
      if (this.options.disableScroll) {
        event.preventDefault()
      }
      // Measure change in x and y coordinates:
      this.touchDelta = {
        x: touch.pageX - this.touchStart.x,
        y: touch.pageY - this.touchStart.y
      }
      touchDeltaX = this.touchDelta.x
      // Detect if this is a vertical scroll movement (run only once per touch):
      if (this.isScrolling === undefined) {
        this.isScrolling =
          this.isScrolling ||
          Math.abs(touchDeltaX) < Math.abs(this.touchDelta.y)
      }
      if (!this.isScrolling) {
        // Always prevent horizontal scroll:
        event.preventDefault()
        // Stop the slideshow:
        window.clearTimeout(this.timeout)
        if (this.options.continuous) {
          indices = [this.circle(index + 1), index, this.circle(index - 1)]
        } else {
          // Increase resistance if first slide and sliding left
          // or last slide and sliding right:
          this.touchDelta.x = touchDeltaX =
            touchDeltaX /
            ((!index && touchDeltaX > 0) ||
            (index === this.num - 1 && touchDeltaX < 0)
              ? Math.abs(touchDeltaX) / this.slideWidth + 1
              : 1)
          indices = [index]
          if (index) {
            indices.push(index - 1)
          }
          if (index < this.num - 1) {
            indices.unshift(index + 1)
          }
        }
        while (indices.length) {
          index = indices.pop()
          this.translateX(index, touchDeltaX + this.positions[index], 0)
        }
      } else if (!this.options.carousel) {
        this.translateY(index, this.touchDelta.y + this.positions[index], 0)
      }
    },

    ontouchend: function (event) {
      if (this.options.stopTouchEventsPropagation) {
        this.stopPropagation(event)
      }
      var index = this.index
      var absTouchDeltaX = Math.abs(this.touchDelta.x)
      var slideWidth = this.slideWidth
      var duration = Math.ceil(
        (this.options.transitionDuration * (1 - absTouchDeltaX / slideWidth)) /
          2
      )
      // Determine if slide attempt triggers next/prev slide:
      var isValidSlide = absTouchDeltaX > 20
      // Determine if slide attempt is past start or end:
      var isPastBounds =
        (!index && this.touchDelta.x > 0) ||
        (index === this.num - 1 && this.touchDelta.x < 0)
      var isValidClose =
        !isValidSlide &&
        this.options.closeOnSwipeUpOrDown &&
        Math.abs(this.touchDelta.y) > 20
      var direction
      var indexForward
      var indexBackward
      var distanceForward
      var distanceBackward
      if (this.options.continuous) {
        isPastBounds = false
      }
      // Determine direction of swipe (true: right, false: left):
      direction = this.touchDelta.x < 0 ? -1 : 1
      if (!this.isScrolling) {
        if (isValidSlide && !isPastBounds) {
          indexForward = index + direction
          indexBackward = index - direction
          distanceForward = slideWidth * direction
          distanceBackward = -slideWidth * direction
          if (this.options.continuous) {
            this.move(this.circle(indexForward), distanceForward, 0)
            this.move(this.circle(index - 2 * direction), distanceBackward, 0)
          } else if (indexForward >= 0 && indexForward < this.num) {
            this.move(indexForward, distanceForward, 0)
          }
          this.move(index, this.positions[index] + distanceForward, duration)
          this.move(
            this.circle(indexBackward),
            this.positions[this.circle(indexBackward)] + distanceForward,
            duration
          )
          index = this.circle(indexBackward)
          this.onslide(index)
        } else {
          // Move back into position
          if (this.options.continuous) {
            this.move(this.circle(index - 1), -slideWidth, duration)
            this.move(index, 0, duration)
            this.move(this.circle(index + 1), slideWidth, duration)
          } else {
            if (index) {
              this.move(index - 1, -slideWidth, duration)
            }
            this.move(index, 0, duration)
            if (index < this.num - 1) {
              this.move(index + 1, slideWidth, duration)
            }
          }
        }
      } else {
        if (isValidClose) {
          this.close()
        } else {
          // Move back into position
          this.translateY(index, 0, duration)
        }
      }
    },

    ontouchcancel: function (event) {
      if (this.touchStart) {
        this.ontouchend(event)
        delete this.touchStart
      }
    },

    ontransitionend: function (event) {
      var slide = this.slides[this.index]
      if (!event || slide === event.target) {
        if (this.interval) {
          this.play()
        }
        this.setTimeout(this.options.onslideend, [this.index, slide])
      }
    },

    oncomplete: function (event) {
      var target = event.target || event.srcElement
      var parent = target && target.parentNode
      var index
      if (!target || !parent) {
        return
      }
      index = this.getNodeIndex(parent)
      $(parent).removeClass(this.options.slideLoadingClass)
      if (event.type === 'error') {
        $(parent).addClass(this.options.slideErrorClass)
        this.elements[index] = 3 // Fail
      } else {
        this.elements[index] = 2 // Done
      }
      // Fix for IE7's lack of support for percentage max-height:
      if (target.clientHeight > this.container[0].clientHeight) {
        target.style.maxHeight = this.container[0].clientHeight
      }
      if (this.interval && this.slides[this.index] === parent) {
        this.play()
      }
      this.setTimeout(this.options.onslidecomplete, [index, parent])
    },

    onload: function (event) {
      this.oncomplete(event)
    },

    onerror: function (event) {
      this.oncomplete(event)
    },

    onkeydown: function (event) {
      switch (event.which || event.keyCode) {
        case 13: // Return
          if (this.options.toggleControlsOnReturn) {
            this.preventDefault(event)
            this.toggleControls()
          }
          break
        case 27: // Esc
          if (this.options.closeOnEscape) {
            this.close()
            // prevent Esc from closing other things
            event.stopImmediatePropagation()
          }
          break
        case 32: // Space
          if (this.options.toggleSlideshowOnSpace) {
            this.preventDefault(event)
            this.toggleSlideshow()
          }
          break
        case 37: // Left
          if (this.options.enableKeyboardNavigation) {
            this.preventDefault(event)
            this.prev()
          }
          break
        case 39: // Right
          if (this.options.enableKeyboardNavigation) {
            this.preventDefault(event)
            this.next()
          }
          break
      }
    },

    handleClick: function (event) {
      var options = this.options
      var target = event.target || event.srcElement
      var parent = target.parentNode
      /**
       * Checks if the target from the close has the given class
       *
       * @param {string} className Class name
       * @returns {boolean} Returns true if the target has the class name
       */
      function isTarget(className) {
        return $(target).hasClass(className) || $(parent).hasClass(className)
      }
      if (isTarget(options.toggleClass)) {
        // Click on "toggle" control
        this.preventDefault(event)
        this.toggleControls()
      } else if (isTarget(options.prevClass)) {
        // Click on "prev" control
        this.preventDefault(event)
        this.prev()
      } else if (isTarget(options.nextClass)) {
        // Click on "next" control
        this.preventDefault(event)
        this.next()
      } else if (isTarget(options.closeClass)) {
        // Click on "close" control
        this.preventDefault(event)
        this.close()
      } else if (isTarget(options.playPauseClass)) {
        // Click on "play-pause" control
        this.preventDefault(event)
        this.toggleSlideshow()
      } else if (parent === this.slidesContainer[0]) {
        // Click on slide background
        if (options.closeOnSlideClick) {
          this.preventDefault(event)
          this.close()
        } else if (options.toggleControlsOnSlideClick) {
          this.preventDefault(event)
          this.toggleControls()
        }
      } else if (
        parent.parentNode &&
        parent.parentNode === this.slidesContainer[0]
      ) {
        // Click on displayed element
        if (options.toggleControlsOnSlideClick) {
          this.preventDefault(event)
          this.toggleControls()
        }
      }
    },

    onclick: function (event) {
      if (
        this.options.emulateTouchEvents &&
        this.touchDelta &&
        (Math.abs(this.touchDelta.x) > 20 || Math.abs(this.touchDelta.y) > 20)
      ) {
        delete this.touchDelta
        return
      }
      return this.handleClick(event)
    },

    updateEdgeClasses: function (index) {
      if (!index) {
        this.container.addClass(this.options.leftEdgeClass)
      } else {
        this.container.removeClass(this.options.leftEdgeClass)
      }
      if (index === this.num - 1) {
        this.container.addClass(this.options.rightEdgeClass)
      } else {
        this.container.removeClass(this.options.rightEdgeClass)
      }
    },

    handleSlide: function (index) {
      if (!this.options.continuous) {
        this.updateEdgeClasses(index)
      }
      this.loadElements(index)
      if (this.options.unloadElements) {
        this.unloadElements(index)
      }
      this.setTitle(index)
    },

    onslide: function (index) {
      this.index = index
      this.handleSlide(index)
      this.setTimeout(this.options.onslide, [index, this.slides[index]])
    },

    setTitle: function (index) {
      var firstChild = this.slides[index].firstChild
      var text = firstChild.title || firstChild.alt
      var titleElement = this.titleElement
      if (titleElement.length) {
        this.titleElement.empty()
        if (text) {
          titleElement[0].appendChild(document.createTextNode(text))
        }
      }
    },

    setTimeout: function (func, args, wait) {
      var that = this
      return (
        func &&
        window.setTimeout(function () {
          func.apply(that, args || [])
        }, wait || 0)
      )
    },

    imageFactory: function (obj, callback) {
      var that = this
      var img = this.imagePrototype.cloneNode(false)
      var url = obj
      var backgroundSize = this.options.stretchImages
      var called
      var element
      var title
      var altText
      /**
       * Wraps the callback function for the load/error event
       *
       * @param {event} event load/error event
       * @returns {number} timeout ID
       */
      function callbackWrapper(event) {
        if (!called) {
          event = {
            type: event.type,
            target: element
          }
          if (!element.parentNode) {
            // Fix for IE7 firing the load event for
            // cached images before the element could
            // be added to the DOM:
            return that.setTimeout(callbackWrapper, [event])
          }
          called = true
          $(img).off('load error', callbackWrapper)
          if (backgroundSize) {
            if (event.type === 'load') {
              element.style.background = 'url("' + url + '") center no-repeat'
              element.style.backgroundSize = backgroundSize
            }
          }
          callback(event)
        }
      }
      if (typeof url !== 'string') {
        url = this.getItemProperty(obj, this.options.urlProperty)
        title = this.getItemProperty(obj, this.options.titleProperty)
        altText =
          this.getItemProperty(obj, this.options.altTextProperty) || title
      }
      if (backgroundSize === true) {
        backgroundSize = 'contain'
      }
      backgroundSize =
        this.support.backgroundSize &&
        this.support.backgroundSize[backgroundSize] &&
        backgroundSize
      if (backgroundSize) {
        element = this.elementPrototype.cloneNode(false)
      } else {
        element = img
        img.draggable = false
      }
      if (title) {
        element.title = title
      }
      if (altText) {
        element.alt = altText
      }
      $(img).on('load error', callbackWrapper)
      img.src = url
      return element
    },

    createElement: function (obj, callback) {
      var type = obj && this.getItemProperty(obj, this.options.typeProperty)
      var factory =
        (type && this[type.split('/')[0] + 'Factory']) || this.imageFactory
      var element = obj && factory.call(this, obj, callback)
      var srcset = this.getItemProperty(obj, this.options.srcsetProperty)
      if (!element) {
        element = this.elementPrototype.cloneNode(false)
        this.setTimeout(callback, [
          {
            type: 'error',
            target: element
          }
        ])
      }
      if (srcset) {
        element.setAttribute('srcset', srcset)
      }
      $(element).addClass(this.options.slideContentClass)
      return element
    },

    loadElement: function (index) {
      if (!this.elements[index]) {
        if (this.slides[index].firstChild) {
          this.elements[index] = $(this.slides[index]).hasClass(
            this.options.slideErrorClass
          )
            ? 3
            : 2
        } else {
          this.elements[index] = 1 // Loading
          $(this.slides[index]).addClass(this.options.slideLoadingClass)
          this.slides[index].appendChild(
            this.createElement(this.list[index], this.proxyListener)
          )
        }
      }
    },

    loadElements: function (index) {
      var limit = Math.min(this.num, this.options.preloadRange * 2 + 1)
      var j = index
      var i
      for (i = 0; i < limit; i += 1) {
        // First load the current slide element (0),
        // then the next one (+1),
        // then the previous one (-2),
        // then the next after next (+2), etc.:
        j += i * (i % 2 === 0 ? -1 : 1)
        // Connect the ends of the list to load slide elements for
        // continuous navigation:
        j = this.circle(j)
        this.loadElement(j)
      }
    },

    unloadElements: function (index) {
      var i, diff
      for (i in this.elements) {
        if (Object.prototype.hasOwnProperty.call(this.elements, i)) {
          diff = Math.abs(index - i)
          if (
            diff > this.options.preloadRange &&
            diff + this.options.preloadRange < this.num
          ) {
            this.unloadSlide(i)
            delete this.elements[i]
          }
        }
      }
    },

    addSlide: function (index) {
      var slide = this.slidePrototype.cloneNode(false)
      slide.setAttribute('data-index', index)
      this.slidesContainer[0].appendChild(slide)
      this.slides.push(slide)
    },

    positionSlide: function (index) {
      var slide = this.slides[index]
      slide.style.width = this.slideWidth + 'px'
      if (this.support.transform) {
        slide.style.left = index * -this.slideWidth + 'px'
        this.move(
          index,
          this.index > index
            ? -this.slideWidth
            : this.index < index
            ? this.slideWidth
            : 0,
          0
        )
      }
    },

    initSlides: function (reload) {
      var clearSlides, i
      if (!reload) {
        this.positions = []
        this.positions.length = this.num
        this.elements = {}
        this.imagePrototype = document.createElement('img')
        this.elementPrototype = document.createElement('div')
        this.slidePrototype = document.createElement('div')
        $(this.slidePrototype).addClass(this.options.slideClass)
        this.slides = this.slidesContainer[0].children
        clearSlides =
          this.options.clearSlides || this.slides.length !== this.num
      }
      this.slideWidth = this.container[0].clientWidth
      this.slideHeight = this.container[0].clientHeight
      this.slidesContainer[0].style.width = this.num * this.slideWidth + 'px'
      if (clearSlides) {
        this.resetSlides()
      }
      for (i = 0; i < this.num; i += 1) {
        if (clearSlides) {
          this.addSlide(i)
        }
        this.positionSlide(i)
      }
      // Reposition the slides before and after the given index:
      if (this.options.continuous && this.support.transform) {
        this.move(this.circle(this.index - 1), -this.slideWidth, 0)
        this.move(this.circle(this.index + 1), this.slideWidth, 0)
      }
      if (!this.support.transform) {
        this.slidesContainer[0].style.left =
          this.index * -this.slideWidth + 'px'
      }
    },

    unloadSlide: function (index) {
      var slide, firstChild
      slide = this.slides[index]
      firstChild = slide.firstChild
      if (firstChild !== null) {
        slide.removeChild(firstChild)
      }
    },

    unloadAllSlides: function () {
      var i, len
      for (i = 0, len = this.slides.length; i < len; i++) {
        this.unloadSlide(i)
      }
    },

    toggleControls: function () {
      var controlsClass = this.options.controlsClass
      if (this.container.hasClass(controlsClass)) {
        this.container.removeClass(controlsClass)
      } else {
        this.container.addClass(controlsClass)
      }
    },

    toggleSlideshow: function () {
      if (!this.interval) {
        this.play()
      } else {
        this.pause()
      }
    },

    getNodeIndex: function (element) {
      return parseInt(element.getAttribute('data-index'), 10)
    },

    getNestedProperty: function (obj, property) {
      property.replace(
        // Matches native JavaScript notation in a String,
        // e.g. '["doubleQuoteProp"].dotProp[2]'
        // eslint-disable-next-line no-useless-escape
        /\[(?:'([^']+)'|"([^"]+)"|(\d+))\]|(?:(?:^|\.)([^\.\[]+))/g,
        function (str, singleQuoteProp, doubleQuoteProp, arrayIndex, dotProp) {
          var prop =
            dotProp ||
            singleQuoteProp ||
            doubleQuoteProp ||
            (arrayIndex && parseInt(arrayIndex, 10))
          if (str && obj) {
            obj = obj[prop]
          }
        }
      )
      return obj
    },

    getDataProperty: function (obj, property) {
      var key
      var prop
      if (obj.dataset) {
        key = property.replace(/-([a-z])/g, function (_, b) {
          return b.toUpperCase()
        })
        prop = obj.dataset[key]
      } else if (obj.getAttribute) {
        prop = obj.getAttribute(
          'data-' + property.replace(/([A-Z])/g, '-$1').toLowerCase()
        )
      }
      if (typeof prop === 'string') {
        // eslint-disable-next-line no-useless-escape
        if (
          /^(true|false|null|-?\d+(\.\d+)?|\{[\s\S]*\}|\[[\s\S]*\])$/.test(prop)
        ) {
          try {
            return $.parseJSON(prop)
          } catch (ignore) {
            // ignore JSON parsing errors
          }
        }
        return prop
      }
    },

    getItemProperty: function (obj, property) {
      var prop = this.getDataProperty(obj, property)
      if (prop === undefined) {
        prop = obj[property]
      }
      if (prop === undefined) {
        prop = this.getNestedProperty(obj, property)
      }
      return prop
    },

    initStartIndex: function () {
      var index = this.options.index
      var urlProperty = this.options.urlProperty
      var i
      // Check if the index is given as a list object:
      if (index && typeof index !== 'number') {
        for (i = 0; i < this.num; i += 1) {
          if (
            this.list[i] === index ||
            this.getItemProperty(this.list[i], urlProperty) ===
              this.getItemProperty(index, urlProperty)
          ) {
            index = i
            break
          }
        }
      }
      // Make sure the index is in the list range:
      this.index = this.circle(parseInt(index, 10) || 0)
    },

    initEventListeners: function () {
      var that = this
      var slidesContainer = this.slidesContainer
      /**
       * Proxy listener
       *
       * @param {event} event original event
       */
      function proxyListener(event) {
        var type =
          that.support.transition && that.support.transition.end === event.type
            ? 'transitionend'
            : event.type
        that['on' + type](event)
      }
      $(window).on('resize', proxyListener)
      $(window).on('hashchange', proxyListener)
      $(document.body).on('keydown', proxyListener)
      this.container.on('click', proxyListener)
      if (this.support.touch) {
        slidesContainer.on(
          'touchstart touchmove touchend touchcancel',
          proxyListener
        )
      } else if (this.options.emulateTouchEvents && this.support.transition) {
        slidesContainer.on(
          'mousedown mousemove mouseup mouseout',
          proxyListener
        )
      }
      if (this.support.transition) {
        slidesContainer.on(this.support.transition.end, proxyListener)
      }
      this.proxyListener = proxyListener
    },

    destroyEventListeners: function () {
      var slidesContainer = this.slidesContainer
      var proxyListener = this.proxyListener
      $(window).off('resize', proxyListener)
      $(document.body).off('keydown', proxyListener)
      this.container.off('click', proxyListener)
      if (this.support.touch) {
        slidesContainer.off(
          'touchstart touchmove touchend touchcancel',
          proxyListener
        )
      } else if (this.options.emulateTouchEvents && this.support.transition) {
        slidesContainer.off(
          'mousedown mousemove mouseup mouseout',
          proxyListener
        )
      }
      if (this.support.transition) {
        slidesContainer.off(this.support.transition.end, proxyListener)
      }
    },

    handleOpen: function () {
      if (this.options.onopened) {
        this.options.onopened.call(this)
      }
    },

    initWidget: function () {
      var that = this
      /**
       * Open handler
       *
       * @param {event} event Gallery open event
       */
      function openHandler(event) {
        if (event.target === that.container[0]) {
          that.container.off(that.support.transition.end, openHandler)
          that.handleOpen()
        }
      }
      this.container = $(this.options.container)
      if (!this.container.length) {
        this.console.log(
          'blueimp Gallery: Widget container not found.',
          this.options.container
        )
        return false
      }
      this.slidesContainer = this.container
        .find(this.options.slidesContainer)
        .first()
      if (!this.slidesContainer.length) {
        this.console.log(
          'blueimp Gallery: Slides container not found.',
          this.options.slidesContainer
        )
        return false
      }
      this.titleElement = this.container.find(this.options.titleElement).first()
      if (this.num === 1) {
        this.container.addClass(this.options.singleClass)
      }
      if (this.options.onopen) {
        this.options.onopen.call(this)
      }
      if (this.support.transition && this.options.displayTransition) {
        this.container.on(this.support.transition.end, openHandler)
      } else {
        this.handleOpen()
      }
      if (this.options.hidePageScrollbars) {
        // Hide the page scrollbars:
        this.bodyOverflowStyle = document.body.style.overflow
        document.body.style.overflow = 'hidden'
      }
      this.container[0].style.display = 'block'
      this.initSlides()
      this.container.addClass(this.options.displayClass)
    },

    initOptions: function (options) {
      // Create a copy of the prototype options:
      this.options = $.extend({}, this.options)
      // Check if carousel mode is enabled:
      if (
        (options && options.carousel) ||
        (this.options.carousel && (!options || options.carousel !== false))
      ) {
        $.extend(this.options, this.carouselOptions)
      }
      // Override any given options:
      $.extend(this.options, options)
      if (this.num < 3) {
        // 1 or 2 slides cannot be displayed continuous,
        // remember the original option by setting to null instead of false:
        this.options.continuous = this.options.continuous ? null : false
      }
      if (!this.support.transition) {
        this.options.emulateTouchEvents = false
      }
      if (this.options.event) {
        this.preventDefault(this.options.event)
      }
    }
  })

  return Gallery
})


/***/ }),

/***/ "./node_modules/blueimp-gallery/js/blueimp-helper.js":
/*!***********************************************************!*\
  !*** ./node_modules/blueimp-gallery/js/blueimp-helper.js ***!
  \***********************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
 * blueimp helper JS
 * https://github.com/blueimp/Gallery
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 */

/* global define */

/* eslint-disable no-param-reassign */

;(function () {
  'use strict'

  /**
   * Object.assign polyfill
   *
   * @param {object} obj1 First object
   * @param {object} obj2 Second object
   * @returns {object} Merged object
   */
  function extend(obj1, obj2) {
    var prop
    for (prop in obj2) {
      if (Object.prototype.hasOwnProperty.call(obj2, prop)) {
        obj1[prop] = obj2[prop]
      }
    }
    return obj1
  }
  /**
   * Helper constructor
   *
   * @class
   * @param {*} query jQuery type query argument
   */
  function Helper(query) {
    if (!this || this.find !== Helper.prototype.find) {
      // Called as function instead of as constructor,
      // so we simply return a new instance:
      return new Helper(query)
    }
    this.length = 0
    if (query) {
      if (typeof query === 'string') {
        query = this.find(query)
      }
      if (query.nodeType || query === query.window) {
        // Single HTML element
        this.length = 1
        this[0] = query
      } else {
        // HTML element collection
        var i = query.length
        this.length = i
        while (i) {
          i -= 1
          this[i] = query[i]
        }
      }
    }
  }

  Helper.extend = extend

  Helper.contains = function (container, element) {
    do {
      element = element.parentNode
      if (element === container) {
        return true
      }
    } while (element)
    return false
  }

  Helper.parseJSON = function (string) {
    return window.JSON && JSON.parse(string)
  }

  extend(Helper.prototype, {
    find: function (query) {
      var container = this[0] || document
      if (typeof query === 'string') {
        if (container.querySelectorAll) {
          query = container.querySelectorAll(query)
        } else if (query.charAt(0) === '#') {
          query = container.getElementById(query.slice(1))
        } else {
          query = container.getElementsByTagName(query)
        }
      }
      return new Helper(query)
    },

    hasClass: function (className) {
      if (!this[0]) {
        return false
      }
      return new RegExp('(^|\\s+)' + className + '(\\s+|$)').test(
        this[0].className
      )
    },

    addClass: function (className) {
      var i = this.length
      var element
      while (i) {
        i -= 1
        element = this[i]
        if (!element.className) {
          element.className = className
          return this
        }
        if (this.hasClass(className)) {
          return this
        }
        element.className += ' ' + className
      }
      return this
    },

    removeClass: function (className) {
      var regexp = new RegExp('(^|\\s+)' + className + '(\\s+|$)')
      var i = this.length
      var element
      while (i) {
        i -= 1
        element = this[i]
        element.className = element.className.replace(regexp, ' ')
      }
      return this
    },

    on: function (eventName, handler) {
      var eventNames = eventName.split(/\s+/)
      var i
      var element
      while (eventNames.length) {
        eventName = eventNames.shift()
        i = this.length
        while (i) {
          i -= 1
          element = this[i]
          if (element.addEventListener) {
            element.addEventListener(eventName, handler, false)
          } else if (element.attachEvent) {
            element.attachEvent('on' + eventName, handler)
          }
        }
      }
      return this
    },

    off: function (eventName, handler) {
      var eventNames = eventName.split(/\s+/)
      var i
      var element
      while (eventNames.length) {
        eventName = eventNames.shift()
        i = this.length
        while (i) {
          i -= 1
          element = this[i]
          if (element.removeEventListener) {
            element.removeEventListener(eventName, handler, false)
          } else if (element.detachEvent) {
            element.detachEvent('on' + eventName, handler)
          }
        }
      }
      return this
    },

    empty: function () {
      var i = this.length
      var element
      while (i) {
        i -= 1
        element = this[i]
        while (element.hasChildNodes()) {
          element.removeChild(element.lastChild)
        }
      }
      return this
    },

    first: function () {
      return new Helper(this[0])
    }
  })

  if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return Helper
    }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
  } else {}
})()


/***/ }),

/***/ "./node_modules/get-youtube-id/index.js":
/*!**********************************************!*\
  !*** ./node_modules/get-youtube-id/index.js ***!
  \**********************************************/
/***/ (function(module) {


(function (root, factory) {
  if (true) {
    module.exports = factory();
  } else {}
}(this, function (exports) {

  return function (url, opts) {
    if (opts == undefined) {
      opts = {fuzzy: true};
    }

    if (/youtu\.?be/.test(url)) {

      // Look first for known patterns
      var i;
      var patterns = [
        /youtu\.be\/([^#\&\?]{11})/,  // youtu.be/<id>
        /\?v=([^#\&\?]{11})/,         // ?v=<id>
        /\&v=([^#\&\?]{11})/,         // &v=<id>
        /embed\/([^#\&\?]{11})/,      // embed/<id>
        /\/v\/([^#\&\?]{11})/         // /v/<id>
      ];

      // If any pattern matches, return the ID
      for (i = 0; i < patterns.length; ++i) {
        if (patterns[i].test(url)) {
          return patterns[i].exec(url)[1];
        }
      }

      if (opts.fuzzy) {
        // If that fails, break it apart by certain characters and look 
        // for the 11 character key
        var tokens = url.split(/[\/\&\?=#\.\s]/g);
        for (i = 0; i < tokens.length; ++i) {
          if (/^[^#\&\?]{11}$/.test(tokens[i])) {
            return tokens[i];
          }
        }
      }
    }

    return null;
  };

}));


/***/ }),

/***/ "./node_modules/blueimp-gallery/css/blueimp-gallery.min.css":
/*!******************************************************************!*\
  !*** ./node_modules/blueimp-gallery/css/blueimp-gallery.min.css ***!
  \******************************************************************/
/***/ (() => {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./node_modules/vue-gallery/dist/js/vue-gallery.js":
/*!*********************************************************!*\
  !*** ./node_modules/vue-gallery/dist/js/vue-gallery.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

(function (global, factory) {
   true ? module.exports = factory(__webpack_require__(/*! blueimp-gallery/css/blueimp-gallery.min.css */ "./node_modules/blueimp-gallery/css/blueimp-gallery.min.css"), __webpack_require__(/*! blueimp-gallery/js/blueimp-gallery-fullscreen.js */ "./node_modules/blueimp-gallery/js/blueimp-gallery-fullscreen.js"), __webpack_require__(/*! blueimp-gallery/js/blueimp-gallery-video.js */ "./node_modules/blueimp-gallery/js/blueimp-gallery-video.js"), __webpack_require__(/*! blueimp-gallery/js/blueimp-gallery-youtube.js */ "./node_modules/blueimp-gallery/js/blueimp-gallery-youtube.js"), __webpack_require__(/*! blueimp-gallery/js/blueimp-gallery.js */ "./node_modules/blueimp-gallery/js/blueimp-gallery.js")) :
  0;
}(this, function (blueimpGallery_min_css, blueimpGalleryFullscreen_js, blueimpGalleryVideo_js, blueimpGalleryYoutube_js, blueimp) { 'use strict';

  blueimp = blueimp && blueimp.hasOwnProperty('default') ? blueimp['default'] : blueimp;

  //
  var script = {
    props: {
      images: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      options: {
        type: Object,
        default: function _default() {
          return {};
        }
      },
      carousel: {
        type: Boolean,
        default: false
      },
      index: {
        type: Number
      },
      id: {
        type: String,
        default: 'blueimp-gallery'
      }
    },
    data: function data() {
      return {
        instance: null
      };
    },
    watch: {
      index: function index(value) {
        if (this.carousel) {
          return;
        }

        if (value !== null) {
          this.open(value);
        } else {
          if (this.instance) {
            this.instance.close();
          }

          this.$emit('close');
        }
      }
    },
    mounted: function mounted() {
      if (this.carousel) {
        this.open();
      }
    },
    destroyed: function destroyed() {
      if (this.instance !== null) {
        this.instance.destroyEventListeners();
        this.instance.close();
        this.instance = null;
      }
    },
    methods: {
      open: function open() {
        var _this = this;

        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var instance = typeof blueimp.Gallery !== 'undefined' ? blueimp.Gallery : blueimp;
        var options = Object.assign({
          toggleControlsOnReturn: false,
          toggleControlsOnSlideClick: false,
          closeOnSlideClick: false,
          carousel: this.carousel,
          container: "#".concat(this.id),
          index: index,
          onopen: function onopen() {
            return _this.$emit('onopen');
          },
          onopened: function onopened() {
            return _this.$emit('onopened');
          },
          onslide: this.onSlideCustom,
          onslideend: function onslideend(index, slide) {
            return _this.$emit('onslideend', {
              index: index,
              slide: slide
            });
          },
          onslidecomplete: function onslidecomplete(index, slide) {
            return _this.$emit('onslidecomplete', {
              index: index,
              slide: slide
            });
          },
          onclose: function onclose() {
            return _this.$emit('close');
          },
          onclosed: function onclosed() {
            return _this.$emit('onclosed');
          }
        }, this.options);

        if (this.carousel) {
          options.container = this.$el;
        }

        this.instance = instance(this.images, options);
      },
      onSlideCustom: function onSlideCustom(index, slide) {
        this.$emit('onslide', {
          index: index,
          slide: slide
        });
        var image = this.images[index];

        if (image !== undefined) {
          var text = image.description;
          var node = this.instance.container.find('.description');

          if (text) {
            node.empty();
            node[0].appendChild(document.createTextNode(text));
          }
        }
      }
    }
  };

  function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
  /* server only */
  , shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    if (typeof shadowMode !== 'boolean') {
      createInjectorSSR = createInjector;
      createInjector = shadowMode;
      shadowMode = false;
    } // Vue.extend constructor export interop.


    var options = typeof script === 'function' ? script.options : script; // render functions

    if (template && template.render) {
      options.render = template.render;
      options.staticRenderFns = template.staticRenderFns;
      options._compiled = true; // functional template

      if (isFunctionalTemplate) {
        options.functional = true;
      }
    } // scopedId


    if (scopeId) {
      options._scopeId = scopeId;
    }

    var hook;

    if (moduleIdentifier) {
      // server build
      hook = function hook(context) {
        // 2.3 injection
        context = context || // cached call
        this.$vnode && this.$vnode.ssrContext || // stateful
        this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
        // 2.2 with runInNewContext: true

        if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
          context = __VUE_SSR_CONTEXT__;
        } // inject component styles


        if (style) {
          style.call(this, createInjectorSSR(context));
        } // register component module identifier for async chunk inference


        if (context && context._registeredComponents) {
          context._registeredComponents.add(moduleIdentifier);
        }
      }; // used by ssr in case component is cached and beforeCreate
      // never gets called


      options._ssrRegister = hook;
    } else if (style) {
      hook = shadowMode ? function () {
        style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
      } : function (context) {
        style.call(this, createInjector(context));
      };
    }

    if (hook) {
      if (options.functional) {
        // register for functional component in vue file
        var originalRender = options.render;

        options.render = function renderWithStyleInjection(h, context) {
          hook.call(context);
          return originalRender(h, context);
        };
      } else {
        // inject component registration as beforeCreate hook
        var existing = options.beforeCreate;
        options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
      }
    }

    return script;
  }

  var normalizeComponent_1 = normalizeComponent;

  var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

  function createInjector(context) {
    return function (id, style) {
      return addStyle(id, style);
    };
  }

  var HEAD = document.head || document.getElementsByTagName('head')[0];
  var styles = {};

  function addStyle(id, css) {
    var group = isOldIE ? css.media || 'default' : id;
    var style = styles[group] || (styles[group] = {
      ids: new Set(),
      styles: []
    });

    if (!style.ids.has(id)) {
      style.ids.add(id);
      var code = css.source;

      if (css.map) {
        // https://developer.chrome.com/devtools/docs/javascript-debugging
        // this makes source maps inside style tags work properly in Chrome
        code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

        code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
      }

      if (!style.element) {
        style.element = document.createElement('style');
        style.element.type = 'text/css';
        if (css.media) style.element.setAttribute('media', css.media);
        HEAD.appendChild(style.element);
      }

      if ('styleSheet' in style.element) {
        style.styles.push(code);
        style.element.styleSheet.cssText = style.styles.filter(Boolean).join('\n');
      } else {
        var index = style.ids.size - 1;
        var textNode = document.createTextNode(code);
        var nodes = style.element.childNodes;
        if (nodes[index]) style.element.removeChild(nodes[index]);
        if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
      }
    }
  }

  var browser = createInjector;

  /* script */
  const __vue_script__ = script;

  /* template */
  var __vue_render__ = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"blueimp-gallery blueimp-gallery-controls",class:{'blueimp-gallery-carousel': _vm.carousel},attrs:{"id":_vm.id}},[_c('div',{staticClass:"slides"}),_vm._v(" "),_c('h3',{staticClass:"title"}),_vm._v(" "),_c('p',{staticClass:"description"}),_vm._v(" "),_c('a',{staticClass:"prev"},[_vm._t("prev",[_vm._v("")])],2),_vm._v(" "),_c('a',{staticClass:"next"},[_vm._t("next",[_vm._v("")])],2),_vm._v(" "),(!_vm.carousel)?_c('a',{staticClass:"close"},[_vm._t("close",[_vm._v("")])],2):_vm._e(),_vm._v(" "),(!_vm.carousel)?_c('ol',{staticClass:"indicator"}):_vm._e(),_vm._v(" "),(_vm.carousel)?_c('a',{staticClass:"play-pause"}):_vm._e()])};
  var __vue_staticRenderFns__ = [];

    /* style */
    const __vue_inject_styles__ = function (inject) {
      if (!inject) return
      inject("data-v-6d2033ba_0", { source: ".blueimp-gallery>.description{position:absolute;top:30px;left:15px;color:#fff;display:none}.blueimp-gallery-controls>.description{display:block}", map: undefined, media: undefined });

    };
    /* scoped */
    const __vue_scope_id__ = undefined;
    /* module identifier */
    const __vue_module_identifier__ = undefined;
    /* functional template */
    const __vue_is_functional_template__ = false;
    /* style inject SSR */
    

    
    var VueGallery = normalizeComponent_1(
      { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
      __vue_inject_styles__,
      __vue_script__,
      __vue_scope_id__,
      __vue_is_functional_template__,
      __vue_module_identifier__,
      browser,
      undefined
    );

  return VueGallery;

}));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tbW9uL2pzL2NodW5rcy92ZW5kb3JzLW5vZGVfbW9kdWxlc19nZXQteW91dHViZS1pZF9pbmRleF9qcy1ub2RlX21vZHVsZXNfdnVlLWdhbGxlcnlfZGlzdF9qc192dWUtZ2FsbGVyeV9qcy5taW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQSxNQUFNLElBQTBDO0FBQ2hEO0FBQ0EsSUFBSSxpQ0FBTyxDQUFDLGtHQUFrQixFQUFFLG9HQUFtQixDQUFDLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsa0dBQUM7QUFDOUQsSUFBSSxLQUFLLEVBR047QUFDSCxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7Ozs7Ozs7Ozs7O0FDckZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7QUFDRDtBQUNBLE1BQU0sSUFBMEM7QUFDaEQ7QUFDQSxJQUFJLGlDQUFPLENBQUMsa0dBQWtCLEVBQUUsb0dBQW1CLENBQUMsb0NBQUUsT0FBTztBQUFBO0FBQUE7QUFBQSxrR0FBQztBQUM5RCxJQUFJLEtBQUssRUFHTjtBQUNILENBQUM7QUFDRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOzs7Ozs7Ozs7OztBQzFLRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQSxNQUFNLElBQTBDO0FBQ2hEO0FBQ0EsSUFBSSxpQ0FBTyxDQUFDLGtHQUFrQixFQUFFLGdIQUF5QixDQUFDLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsa0dBQUM7QUFDcEUsSUFBSSxLQUFLLEVBR047QUFDSCxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7QUNoT0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQztBQUNEO0FBQ0EsTUFBTSxJQUEwQztBQUNoRDtBQUNBLElBQUksaUNBQU8sQ0FBQyxrR0FBa0IsQ0FBQyxvQ0FBRSxPQUFPO0FBQUE7QUFBQTtBQUFBLGtHQUFDO0FBQ3pDLElBQUksS0FBSyxFQUlOO0FBQ0gsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0IsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsY0FBYztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekIsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QixtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7QUNyOENEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxNQUFNLElBQTBDO0FBQ2hELElBQUksbUNBQU87QUFDWDtBQUNBLEtBQUs7QUFBQSxrR0FBQztBQUNOLElBQUksS0FBSyxFQUdOO0FBQ0gsQ0FBQzs7Ozs7Ozs7Ozs7O0FDMU1EO0FBQ0EsTUFBTSxJQUEyQjtBQUNqQztBQUNBLElBQUksS0FBSyxFQUlOO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixHQUFHO0FBQ2pDLHVCQUF1QixHQUFHO0FBQzFCLHVCQUF1QixHQUFHO0FBQzFCLDBCQUEwQixHQUFHO0FBQzdCLHdCQUF3QixHQUFHO0FBQzNCOztBQUVBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkMseUJBQXlCLEdBQUc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7Ozs7Ozs7Ozs7O0FDbEREOzs7Ozs7Ozs7O0FDQUE7QUFDQSxFQUFFLEtBQTRELDRCQUE0QixtQkFBTyxDQUFDLCtHQUE2QyxHQUFHLG1CQUFPLENBQUMseUhBQWtELEdBQUcsbUJBQU8sQ0FBQywrR0FBNkMsR0FBRyxtQkFBTyxDQUFDLG1IQUErQyxHQUFHLG1CQUFPLENBQUMsbUdBQXVDO0FBQ2hYLEVBQUUsQ0FDOEY7QUFDaEcsQ0FBQyxtSUFBbUk7O0FBRXBJOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOLDBFQUEwRTs7QUFFMUU7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFOztBQUVBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOzs7QUFHQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7O0FBRWpFLDhEQUE4RDtBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLGFBQWEsMEJBQTBCLHdCQUF3QixpQkFBaUIsOERBQThELHlDQUF5QyxRQUFRLGFBQWEsWUFBWSxxQkFBcUIsdUJBQXVCLG9CQUFvQixzQkFBc0IsMEJBQTBCLHNCQUFzQixtQkFBbUIsdURBQXVELG1CQUFtQix1RUFBdUUsb0JBQW9CLGtGQUFrRix3QkFBd0IsOENBQThDLHlCQUF5QjtBQUMzdUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHVDQUF1QyxrQkFBa0IsU0FBUyxVQUFVLFdBQVcsYUFBYSx1Q0FBdUMsY0FBYyxxQ0FBcUM7O0FBRWxPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxrRUFBa0U7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYW5pbWFsX3Jlc2N1ZV9zb3JhLy4vbm9kZV9tb2R1bGVzL2JsdWVpbXAtZ2FsbGVyeS9qcy9ibHVlaW1wLWdhbGxlcnktZnVsbHNjcmVlbi5qcyIsIndlYnBhY2s6Ly9hbmltYWxfcmVzY3VlX3NvcmEvLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1nYWxsZXJ5L2pzL2JsdWVpbXAtZ2FsbGVyeS12aWRlby5qcyIsIndlYnBhY2s6Ly9hbmltYWxfcmVzY3VlX3NvcmEvLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1nYWxsZXJ5L2pzL2JsdWVpbXAtZ2FsbGVyeS15b3V0dWJlLmpzIiwid2VicGFjazovL2FuaW1hbF9yZXNjdWVfc29yYS8uL25vZGVfbW9kdWxlcy9ibHVlaW1wLWdhbGxlcnkvanMvYmx1ZWltcC1nYWxsZXJ5LmpzIiwid2VicGFjazovL2FuaW1hbF9yZXNjdWVfc29yYS8uL25vZGVfbW9kdWxlcy9ibHVlaW1wLWdhbGxlcnkvanMvYmx1ZWltcC1oZWxwZXIuanMiLCJ3ZWJwYWNrOi8vYW5pbWFsX3Jlc2N1ZV9zb3JhLy4vbm9kZV9tb2R1bGVzL2dldC15b3V0dWJlLWlkL2luZGV4LmpzIiwid2VicGFjazovL2FuaW1hbF9yZXNjdWVfc29yYS8uL25vZGVfbW9kdWxlcy9ibHVlaW1wLWdhbGxlcnkvY3NzL2JsdWVpbXAtZ2FsbGVyeS5taW4uY3NzIiwid2VicGFjazovL2FuaW1hbF9yZXNjdWVfc29yYS8uL25vZGVfbW9kdWxlcy92dWUtZ2FsbGVyeS9kaXN0L2pzL3Z1ZS1nYWxsZXJ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBibHVlaW1wIEdhbGxlcnkgRnVsbHNjcmVlbiBKU1xuICogaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvR2FsbGVyeVxuICpcbiAqIENvcHlyaWdodCAyMDEzLCBTZWJhc3RpYW4gVHNjaGFuXG4gKiBodHRwczovL2JsdWVpbXAubmV0XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuXG4vKiBnbG9iYWwgZGVmaW5lICovXG5cbjsoZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgJ3VzZSBzdHJpY3QnXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgQU1EIG1vZHVsZTpcbiAgICBkZWZpbmUoWycuL2JsdWVpbXAtaGVscGVyJywgJy4vYmx1ZWltcC1nYWxsZXJ5J10sIGZhY3RvcnkpXG4gIH0gZWxzZSB7XG4gICAgLy8gQnJvd3NlciBnbG9iYWxzOlxuICAgIGZhY3Rvcnkod2luZG93LmJsdWVpbXAuaGVscGVyIHx8IHdpbmRvdy5qUXVlcnksIHdpbmRvdy5ibHVlaW1wLkdhbGxlcnkpXG4gIH1cbn0pKGZ1bmN0aW9uICgkLCBHYWxsZXJ5KSB7XG4gICd1c2Ugc3RyaWN0J1xuXG4gIHZhciBnYWxsZXJ5UHJvdG90eXBlID0gR2FsbGVyeS5wcm90b3R5cGVcblxuICAkLmV4dGVuZChnYWxsZXJ5UHJvdG90eXBlLm9wdGlvbnMsIHtcbiAgICAvLyBEZWZpbmVzIGlmIHRoZSBnYWxsZXJ5IHNob3VsZCBvcGVuIGluIGZ1bGxzY3JlZW4gbW9kZTpcbiAgICBmdWxsU2NyZWVuOiBmYWxzZVxuICB9KVxuXG4gIHZhciBpbml0aWFsaXplID0gZ2FsbGVyeVByb3RvdHlwZS5pbml0aWFsaXplXG4gIHZhciBjbG9zZSA9IGdhbGxlcnlQcm90b3R5cGUuY2xvc2VcblxuICAkLmV4dGVuZChnYWxsZXJ5UHJvdG90eXBlLCB7XG4gICAgZ2V0RnVsbFNjcmVlbkVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50IHx8XG4gICAgICAgIGRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50IHx8XG4gICAgICAgIGRvY3VtZW50Lm1vekZ1bGxTY3JlZW5FbGVtZW50IHx8XG4gICAgICAgIGRvY3VtZW50Lm1zRnVsbHNjcmVlbkVsZW1lbnRcbiAgICAgIClcbiAgICB9LFxuXG4gICAgcmVxdWVzdEZ1bGxTY3JlZW46IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICBpZiAoZWxlbWVudC5yZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgICAgICBlbGVtZW50LnJlcXVlc3RGdWxsc2NyZWVuKClcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgICAgICBlbGVtZW50LndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKClcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5tb3pSZXF1ZXN0RnVsbFNjcmVlbikge1xuICAgICAgICBlbGVtZW50Lm1velJlcXVlc3RGdWxsU2NyZWVuKClcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5tc1JlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgICAgIGVsZW1lbnQubXNSZXF1ZXN0RnVsbHNjcmVlbigpXG4gICAgICB9XG4gICAgfSxcblxuICAgIGV4aXRGdWxsU2NyZWVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4oKVxuICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC53ZWJraXRDYW5jZWxGdWxsU2NyZWVuKSB7XG4gICAgICAgIGRvY3VtZW50LndlYmtpdENhbmNlbEZ1bGxTY3JlZW4oKVxuICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC5tb3pDYW5jZWxGdWxsU2NyZWVuKSB7XG4gICAgICAgIGRvY3VtZW50Lm1vekNhbmNlbEZ1bGxTY3JlZW4oKVxuICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC5tc0V4aXRGdWxsc2NyZWVuKSB7XG4gICAgICAgIGRvY3VtZW50Lm1zRXhpdEZ1bGxzY3JlZW4oKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpbml0aWFsaXplLmNhbGwodGhpcylcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZnVsbFNjcmVlbiAmJiAhdGhpcy5nZXRGdWxsU2NyZWVuRWxlbWVudCgpKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdEZ1bGxTY3JlZW4odGhpcy5jb250YWluZXJbMF0pXG4gICAgICB9XG4gICAgfSxcblxuICAgIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5nZXRGdWxsU2NyZWVuRWxlbWVudCgpID09PSB0aGlzLmNvbnRhaW5lclswXSkge1xuICAgICAgICB0aGlzLmV4aXRGdWxsU2NyZWVuKClcbiAgICAgIH1cbiAgICAgIGNsb3NlLmNhbGwodGhpcylcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIEdhbGxlcnlcbn0pXG4iLCIvKlxuICogYmx1ZWltcCBHYWxsZXJ5IFZpZGVvIEZhY3RvcnkgSlNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ibHVlaW1wL0dhbGxlcnlcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMywgU2ViYXN0aWFuIFRzY2hhblxuICogaHR0cHM6Ly9ibHVlaW1wLm5ldFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKi9cblxuLyogZ2xvYmFsIGRlZmluZSAqL1xuXG47KGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICd1c2Ugc3RyaWN0J1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIEFNRCBtb2R1bGU6XG4gICAgZGVmaW5lKFsnLi9ibHVlaW1wLWhlbHBlcicsICcuL2JsdWVpbXAtZ2FsbGVyeSddLCBmYWN0b3J5KVxuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFsczpcbiAgICBmYWN0b3J5KHdpbmRvdy5ibHVlaW1wLmhlbHBlciB8fCB3aW5kb3cualF1ZXJ5LCB3aW5kb3cuYmx1ZWltcC5HYWxsZXJ5KVxuICB9XG59KShmdW5jdGlvbiAoJCwgR2FsbGVyeSkge1xuICAndXNlIHN0cmljdCdcblxuICB2YXIgZ2FsbGVyeVByb3RvdHlwZSA9IEdhbGxlcnkucHJvdG90eXBlXG5cbiAgJC5leHRlbmQoZ2FsbGVyeVByb3RvdHlwZS5vcHRpb25zLCB7XG4gICAgLy8gVGhlIGNsYXNzIGZvciB2aWRlbyBjb250ZW50IGVsZW1lbnRzOlxuICAgIHZpZGVvQ29udGVudENsYXNzOiAndmlkZW8tY29udGVudCcsXG4gICAgLy8gVGhlIGNsYXNzIGZvciB2aWRlbyB3aGVuIGl0IGlzIGxvYWRpbmc6XG4gICAgdmlkZW9Mb2FkaW5nQ2xhc3M6ICd2aWRlby1sb2FkaW5nJyxcbiAgICAvLyBUaGUgY2xhc3MgZm9yIHZpZGVvIHdoZW4gaXQgaXMgcGxheWluZzpcbiAgICB2aWRlb1BsYXlpbmdDbGFzczogJ3ZpZGVvLXBsYXlpbmcnLFxuICAgIC8vIFRoZSBsaXN0IG9iamVjdCBwcm9wZXJ0eSAob3IgZGF0YSBhdHRyaWJ1dGUpIGZvciB0aGUgdmlkZW8gcG9zdGVyIFVSTDpcbiAgICB2aWRlb1Bvc3RlclByb3BlcnR5OiAncG9zdGVyJyxcbiAgICAvLyBUaGUgbGlzdCBvYmplY3QgcHJvcGVydHkgKG9yIGRhdGEgYXR0cmlidXRlKSBmb3IgdGhlIHZpZGVvIHNvdXJjZXMgYXJyYXk6XG4gICAgdmlkZW9Tb3VyY2VzUHJvcGVydHk6ICdzb3VyY2VzJ1xuICB9KVxuXG4gIHZhciBoYW5kbGVTbGlkZSA9IGdhbGxlcnlQcm90b3R5cGUuaGFuZGxlU2xpZGVcblxuICAkLmV4dGVuZChnYWxsZXJ5UHJvdG90eXBlLCB7XG4gICAgaGFuZGxlU2xpZGU6IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgaGFuZGxlU2xpZGUuY2FsbCh0aGlzLCBpbmRleClcbiAgICAgIGlmICh0aGlzLnBsYXlpbmdWaWRlbykge1xuICAgICAgICB0aGlzLnBsYXlpbmdWaWRlby5wYXVzZSgpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHZpZGVvRmFjdG9yeTogZnVuY3Rpb24gKG9iaiwgY2FsbGJhY2ssIHZpZGVvSW50ZXJmYWNlKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG4gICAgICB2YXIgdmlkZW9Db250YWluZXJOb2RlID0gdGhpcy5lbGVtZW50UHJvdG90eXBlLmNsb25lTm9kZShmYWxzZSlcbiAgICAgIHZhciB2aWRlb0NvbnRhaW5lciA9ICQodmlkZW9Db250YWluZXJOb2RlKVxuICAgICAgdmFyIGVycm9yQXJncyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgdGFyZ2V0OiB2aWRlb0NvbnRhaW5lck5vZGVcbiAgICAgICAgfVxuICAgICAgXVxuICAgICAgdmFyIHZpZGVvID0gdmlkZW9JbnRlcmZhY2UgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKVxuICAgICAgdmFyIHVybCA9IHRoaXMuZ2V0SXRlbVByb3BlcnR5KG9iaiwgb3B0aW9ucy51cmxQcm9wZXJ0eSlcbiAgICAgIHZhciB0eXBlID0gdGhpcy5nZXRJdGVtUHJvcGVydHkob2JqLCBvcHRpb25zLnR5cGVQcm9wZXJ0eSlcbiAgICAgIHZhciB0aXRsZSA9IHRoaXMuZ2V0SXRlbVByb3BlcnR5KG9iaiwgb3B0aW9ucy50aXRsZVByb3BlcnR5KVxuICAgICAgdmFyIGFsdFRleHQgPVxuICAgICAgICB0aGlzLmdldEl0ZW1Qcm9wZXJ0eShvYmosIHRoaXMub3B0aW9ucy5hbHRUZXh0UHJvcGVydHkpIHx8IHRpdGxlXG4gICAgICB2YXIgcG9zdGVyVXJsID0gdGhpcy5nZXRJdGVtUHJvcGVydHkob2JqLCBvcHRpb25zLnZpZGVvUG9zdGVyUHJvcGVydHkpXG4gICAgICB2YXIgcG9zdGVySW1hZ2VcbiAgICAgIHZhciBzb3VyY2VzID0gdGhpcy5nZXRJdGVtUHJvcGVydHkob2JqLCBvcHRpb25zLnZpZGVvU291cmNlc1Byb3BlcnR5KVxuICAgICAgdmFyIHNvdXJjZVxuICAgICAgdmFyIHBsYXlNZWRpYUNvbnRyb2xcbiAgICAgIHZhciBpc0xvYWRpbmdcbiAgICAgIHZhciBoYXNDb250cm9sc1xuICAgICAgdmlkZW9Db250YWluZXIuYWRkQ2xhc3Mob3B0aW9ucy52aWRlb0NvbnRlbnRDbGFzcylcbiAgICAgIGlmICh0aXRsZSkge1xuICAgICAgICB2aWRlb0NvbnRhaW5lck5vZGUudGl0bGUgPSB0aXRsZVxuICAgICAgfVxuICAgICAgaWYgKHZpZGVvLmNhblBsYXlUeXBlKSB7XG4gICAgICAgIGlmICh1cmwgJiYgdHlwZSAmJiB2aWRlby5jYW5QbGF5VHlwZSh0eXBlKSkge1xuICAgICAgICAgIHZpZGVvLnNyYyA9IHVybFxuICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZXMpIHtcbiAgICAgICAgICB3aGlsZSAoc291cmNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZXMuc2hpZnQoKVxuICAgICAgICAgICAgdXJsID0gdGhpcy5nZXRJdGVtUHJvcGVydHkoc291cmNlLCBvcHRpb25zLnVybFByb3BlcnR5KVxuICAgICAgICAgICAgdHlwZSA9IHRoaXMuZ2V0SXRlbVByb3BlcnR5KHNvdXJjZSwgb3B0aW9ucy50eXBlUHJvcGVydHkpXG4gICAgICAgICAgICBpZiAodXJsICYmIHR5cGUgJiYgdmlkZW8uY2FuUGxheVR5cGUodHlwZSkpIHtcbiAgICAgICAgICAgICAgdmlkZW8uc3JjID0gdXJsXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocG9zdGVyVXJsKSB7XG4gICAgICAgIHZpZGVvLnBvc3RlciA9IHBvc3RlclVybFxuICAgICAgICBwb3N0ZXJJbWFnZSA9IHRoaXMuaW1hZ2VQcm90b3R5cGUuY2xvbmVOb2RlKGZhbHNlKVxuICAgICAgICAkKHBvc3RlckltYWdlKS5hZGRDbGFzcyhvcHRpb25zLnRvZ2dsZUNsYXNzKVxuICAgICAgICBwb3N0ZXJJbWFnZS5zcmMgPSBwb3N0ZXJVcmxcbiAgICAgICAgcG9zdGVySW1hZ2UuZHJhZ2dhYmxlID0gZmFsc2VcbiAgICAgICAgcG9zdGVySW1hZ2UuYWx0ID0gYWx0VGV4dFxuICAgICAgICB2aWRlb0NvbnRhaW5lck5vZGUuYXBwZW5kQ2hpbGQocG9zdGVySW1hZ2UpXG4gICAgICB9XG4gICAgICBwbGF5TWVkaWFDb250cm9sID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpXG4gICAgICBwbGF5TWVkaWFDb250cm9sLnNldEF0dHJpYnV0ZSgndGFyZ2V0JywgJ19ibGFuaycpXG4gICAgICBpZiAoIXZpZGVvSW50ZXJmYWNlKSB7XG4gICAgICAgIHBsYXlNZWRpYUNvbnRyb2wuc2V0QXR0cmlidXRlKCdkb3dubG9hZCcsIHRpdGxlKVxuICAgICAgfVxuICAgICAgcGxheU1lZGlhQ29udHJvbC5ocmVmID0gdXJsXG4gICAgICBpZiAodmlkZW8uc3JjKSB7XG4gICAgICAgIHZpZGVvLmNvbnRyb2xzID0gdHJ1ZVxuICAgICAgICA7KHZpZGVvSW50ZXJmYWNlIHx8ICQodmlkZW8pKVxuICAgICAgICAgIC5vbignZXJyb3InLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0LnNldFRpbWVvdXQoY2FsbGJhY2ssIGVycm9yQXJncylcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5vbigncGF1c2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodmlkZW8uc2Vla2luZykgcmV0dXJuXG4gICAgICAgICAgICBpc0xvYWRpbmcgPSBmYWxzZVxuICAgICAgICAgICAgdmlkZW9Db250YWluZXJcbiAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKHRoYXQub3B0aW9ucy52aWRlb0xvYWRpbmdDbGFzcylcbiAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKHRoYXQub3B0aW9ucy52aWRlb1BsYXlpbmdDbGFzcylcbiAgICAgICAgICAgIGlmIChoYXNDb250cm9scykge1xuICAgICAgICAgICAgICB0aGF0LmNvbnRhaW5lci5hZGRDbGFzcyh0aGF0Lm9wdGlvbnMuY29udHJvbHNDbGFzcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSB0aGF0LnBsYXlpbmdWaWRlb1xuICAgICAgICAgICAgaWYgKHRoYXQuaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgdGhhdC5wbGF5KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIC5vbigncGxheWluZycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlzTG9hZGluZyA9IGZhbHNlXG4gICAgICAgICAgICB2aWRlb0NvbnRhaW5lclxuICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3ModGhhdC5vcHRpb25zLnZpZGVvTG9hZGluZ0NsYXNzKVxuICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhhdC5vcHRpb25zLnZpZGVvUGxheWluZ0NsYXNzKVxuICAgICAgICAgICAgaWYgKHRoYXQuY29udGFpbmVyLmhhc0NsYXNzKHRoYXQub3B0aW9ucy5jb250cm9sc0NsYXNzKSkge1xuICAgICAgICAgICAgICBoYXNDb250cm9scyA9IHRydWVcbiAgICAgICAgICAgICAgdGhhdC5jb250YWluZXIucmVtb3ZlQ2xhc3ModGhhdC5vcHRpb25zLmNvbnRyb2xzQ2xhc3MpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBoYXNDb250cm9scyA9IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICAub24oJ3BsYXknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoYXQudGltZW91dClcbiAgICAgICAgICAgIGlzTG9hZGluZyA9IHRydWVcbiAgICAgICAgICAgIHZpZGVvQ29udGFpbmVyLmFkZENsYXNzKHRoYXQub3B0aW9ucy52aWRlb0xvYWRpbmdDbGFzcylcbiAgICAgICAgICAgIHRoYXQucGxheWluZ1ZpZGVvID0gdmlkZW9cbiAgICAgICAgICB9KVxuICAgICAgICAkKHBsYXlNZWRpYUNvbnRyb2wpLm9uKCdjbGljaycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIHRoYXQucHJldmVudERlZmF1bHQoZXZlbnQpXG4gICAgICAgICAgaWYgKGlzTG9hZGluZykge1xuICAgICAgICAgICAgdmlkZW8ucGF1c2UoKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aWRlby5wbGF5KClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIHZpZGVvQ29udGFpbmVyTm9kZS5hcHBlbmRDaGlsZChcbiAgICAgICAgICAodmlkZW9JbnRlcmZhY2UgJiYgdmlkZW9JbnRlcmZhY2UuZWxlbWVudCkgfHwgdmlkZW9cbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgdmlkZW9Db250YWluZXJOb2RlLmFwcGVuZENoaWxkKHBsYXlNZWRpYUNvbnRyb2wpXG4gICAgICB0aGlzLnNldFRpbWVvdXQoY2FsbGJhY2ssIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6ICdsb2FkJyxcbiAgICAgICAgICB0YXJnZXQ6IHZpZGVvQ29udGFpbmVyTm9kZVxuICAgICAgICB9XG4gICAgICBdKVxuICAgICAgcmV0dXJuIHZpZGVvQ29udGFpbmVyTm9kZVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gR2FsbGVyeVxufSlcbiIsIi8qXG4gKiBibHVlaW1wIEdhbGxlcnkgWW91VHViZSBWaWRlbyBGYWN0b3J5IEpTXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9HYWxsZXJ5XG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIFNlYmFzdGlhbiBUc2NoYW5cbiAqIGh0dHBzOi8vYmx1ZWltcC5uZXRcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICovXG5cbi8qIGdsb2JhbCBkZWZpbmUsIFlUICovXG5cbjsoZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgJ3VzZSBzdHJpY3QnXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgQU1EIG1vZHVsZTpcbiAgICBkZWZpbmUoWycuL2JsdWVpbXAtaGVscGVyJywgJy4vYmx1ZWltcC1nYWxsZXJ5LXZpZGVvJ10sIGZhY3RvcnkpXG4gIH0gZWxzZSB7XG4gICAgLy8gQnJvd3NlciBnbG9iYWxzOlxuICAgIGZhY3Rvcnkod2luZG93LmJsdWVpbXAuaGVscGVyIHx8IHdpbmRvdy5qUXVlcnksIHdpbmRvdy5ibHVlaW1wLkdhbGxlcnkpXG4gIH1cbn0pKGZ1bmN0aW9uICgkLCBHYWxsZXJ5KSB7XG4gICd1c2Ugc3RyaWN0J1xuXG4gIGlmICghd2luZG93LnBvc3RNZXNzYWdlKSB7XG4gICAgcmV0dXJuIEdhbGxlcnlcbiAgfVxuXG4gIHZhciBnYWxsZXJ5UHJvdG90eXBlID0gR2FsbGVyeS5wcm90b3R5cGVcblxuICAkLmV4dGVuZChnYWxsZXJ5UHJvdG90eXBlLm9wdGlvbnMsIHtcbiAgICAvLyBUaGUgbGlzdCBvYmplY3QgcHJvcGVydHkgKG9yIGRhdGEgYXR0cmlidXRlKSB3aXRoIHRoZSBZb3VUdWJlIHZpZGVvIGlkOlxuICAgIHlvdVR1YmVWaWRlb0lkUHJvcGVydHk6ICd5b3V0dWJlJyxcbiAgICAvLyBPcHRpb25hbCBvYmplY3Qgd2l0aCBwYXJhbWV0ZXJzIHBhc3NlZCB0byB0aGUgWW91VHViZSB2aWRlbyBwbGF5ZXI6XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20veW91dHViZS9wbGF5ZXJfcGFyYW1ldGVyc1xuICAgIHlvdVR1YmVQbGF5ZXJWYXJzOiB7XG4gICAgICB3bW9kZTogJ3RyYW5zcGFyZW50J1xuICAgIH0sXG4gICAgLy8gUmVxdWlyZSBhIGNsaWNrIG9uIHRoZSBuYXRpdmUgWW91VHViZSBwbGF5ZXIgZm9yIHRoZSBpbml0aWFsIHBsYXliYWNrOlxuICAgIHlvdVR1YmVDbGlja1RvUGxheTogdHJ1ZVxuICB9KVxuXG4gIHZhciB0ZXh0RmFjdG9yeSA9XG4gICAgZ2FsbGVyeVByb3RvdHlwZS50ZXh0RmFjdG9yeSB8fCBnYWxsZXJ5UHJvdG90eXBlLmltYWdlRmFjdG9yeVxuICB2YXIgWW91VHViZVBsYXllciA9IGZ1bmN0aW9uICh2aWRlb0lkLCBwbGF5ZXJWYXJzLCBjbGlja1RvUGxheSkge1xuICAgIHRoaXMudmlkZW9JZCA9IHZpZGVvSWRcbiAgICB0aGlzLnBsYXllclZhcnMgPSBwbGF5ZXJWYXJzXG4gICAgdGhpcy5jbGlja1RvUGxheSA9IGNsaWNrVG9QbGF5XG4gICAgdGhpcy5lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB0aGlzLmxpc3RlbmVycyA9IHt9XG4gIH1cblxuICAkLmV4dGVuZChZb3VUdWJlUGxheWVyLnByb3RvdHlwZSwge1xuICAgIGNhblBsYXlUeXBlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0sXG5cbiAgICBvbjogZnVuY3Rpb24gKHR5cGUsIGZ1bmMpIHtcbiAgICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdID0gZnVuY1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuXG4gICAgbG9hZEFQSTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgICB2YXIgb25Zb3VUdWJlSWZyYW1lQVBJUmVhZHkgPSB3aW5kb3cub25Zb3VUdWJlSWZyYW1lQVBJUmVhZHlcbiAgICAgIHZhciBhcGlVcmwgPSAnLy93d3cueW91dHViZS5jb20vaWZyYW1lX2FwaSdcbiAgICAgIHZhciBzY3JpcHRUYWdzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpXG4gICAgICB2YXIgaSA9IHNjcmlwdFRhZ3MubGVuZ3RoXG4gICAgICB2YXIgc2NyaXB0VGFnXG4gICAgICB3aW5kb3cub25Zb3VUdWJlSWZyYW1lQVBJUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChvbllvdVR1YmVJZnJhbWVBUElSZWFkeSkge1xuICAgICAgICAgIG9uWW91VHViZUlmcmFtZUFQSVJlYWR5LmFwcGx5KHRoaXMpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoYXQucGxheU9uUmVhZHkpIHtcbiAgICAgICAgICB0aGF0LnBsYXkoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoaSkge1xuICAgICAgICBpIC09IDFcbiAgICAgICAgaWYgKHNjcmlwdFRhZ3NbaV0uc3JjID09PSBhcGlVcmwpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2NyaXB0VGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcbiAgICAgIHNjcmlwdFRhZy5zcmMgPSBhcGlVcmxcbiAgICAgIHNjcmlwdFRhZ3NbMF0ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2NyaXB0VGFnLCBzY3JpcHRUYWdzWzBdKVxuICAgIH0sXG5cbiAgICBvblJlYWR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnJlYWR5ID0gdHJ1ZVxuICAgICAgaWYgKHRoaXMucGxheU9uUmVhZHkpIHtcbiAgICAgICAgdGhpcy5wbGF5KClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb25QbGF5aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5wbGF5U3RhdHVzIDwgMikge1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5wbGF5aW5nKClcbiAgICAgICAgdGhpcy5wbGF5U3RhdHVzID0gMlxuICAgICAgfVxuICAgIH0sXG5cbiAgICBvblBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBnYWxsZXJ5UHJvdG90eXBlLnNldFRpbWVvdXQuY2FsbCh0aGlzLCB0aGlzLmNoZWNrU2VlaywgbnVsbCwgMjAwMClcbiAgICB9LFxuXG4gICAgY2hlY2tTZWVrOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2UgPT09IFlULlBsYXllclN0YXRlLlBBVVNFRCB8fFxuICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlID09PSBZVC5QbGF5ZXJTdGF0ZS5FTkRFRFxuICAgICAgKSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIGN1cnJlbnQgc3RhdGUgY2hhbmdlIGlzIGFjdHVhbGx5IHBhdXNlZFxuICAgICAgICB0aGlzLmxpc3RlbmVycy5wYXVzZSgpXG4gICAgICAgIGRlbGV0ZSB0aGlzLnBsYXlTdGF0dXNcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb25TdGF0ZUNoYW5nZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBzd2l0Y2ggKGV2ZW50LmRhdGEpIHtcbiAgICAgICAgY2FzZSBZVC5QbGF5ZXJTdGF0ZS5QTEFZSU5HOlxuICAgICAgICAgIHRoaXMuaGFzUGxheWVkID0gdHJ1ZVxuICAgICAgICAgIHRoaXMub25QbGF5aW5nKClcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIFlULlBsYXllclN0YXRlLlBBVVNFRDpcbiAgICAgICAgY2FzZSBZVC5QbGF5ZXJTdGF0ZS5FTkRFRDpcbiAgICAgICAgICB0aGlzLm9uUGF1c2UoKVxuICAgICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICAvLyBTYXZlIG1vc3QgcmVjZW50IHN0YXRlIGNoYW5nZSB0byB0aGlzLnN0YXRlQ2hhbmdlXG4gICAgICB0aGlzLnN0YXRlQ2hhbmdlID0gZXZlbnQuZGF0YVxuICAgIH0sXG5cbiAgICBvbkVycm9yOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHRoaXMubGlzdGVuZXJzLmVycm9yKGV2ZW50KVxuICAgIH0sXG5cbiAgICBwbGF5OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAgIGlmICghdGhpcy5wbGF5U3RhdHVzKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLnBsYXkoKVxuICAgICAgICB0aGlzLnBsYXlTdGF0dXMgPSAxXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yZWFkeSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIXRoaXMuaGFzUGxheWVkICYmXG4gICAgICAgICAgKHRoaXMuY2xpY2tUb1BsYXkgfHxcbiAgICAgICAgICAgICh3aW5kb3cubmF2aWdhdG9yICYmXG4gICAgICAgICAgICAgIC9pUChob25lfG9kfGFkKS8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtKSkpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIE1hbnVhbGx5IHRyaWdnZXIgdGhlIHBsYXlpbmcgY2FsbGJhY2sgaWYgY2xpY2tUb1BsYXlcbiAgICAgICAgICAvLyBpcyBlbmFibGVkIGFuZCB0byB3b3JrYXJvdW5kIGEgbGltaXRhdGlvbiBpbiBpT1MsXG4gICAgICAgICAgLy8gd2hpY2ggcmVxdWlyZXMgc3luY2hyb25vdXMgdXNlciBpbnRlcmFjdGlvbiB0byBzdGFydFxuICAgICAgICAgIC8vIHRoZSB2aWRlbyBwbGF5YmFjazpcbiAgICAgICAgICB0aGlzLm9uUGxheWluZygpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wbGF5ZXIucGxheVZpZGVvKClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wbGF5T25SZWFkeSA9IHRydWVcbiAgICAgICAgaWYgKCEod2luZG93LllUICYmIFlULlBsYXllcikpIHtcbiAgICAgICAgICB0aGlzLmxvYWRBUEkoKVxuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLnBsYXllcikge1xuICAgICAgICAgIHRoaXMucGxheWVyID0gbmV3IFlULlBsYXllcih0aGlzLmVsZW1lbnQsIHtcbiAgICAgICAgICAgIHZpZGVvSWQ6IHRoaXMudmlkZW9JZCxcbiAgICAgICAgICAgIHBsYXllclZhcnM6IHRoaXMucGxheWVyVmFycyxcbiAgICAgICAgICAgIGV2ZW50czoge1xuICAgICAgICAgICAgICBvblJlYWR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5vblJlYWR5KClcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgb25TdGF0ZUNoYW5nZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhhdC5vblN0YXRlQ2hhbmdlKGV2ZW50KVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBvbkVycm9yOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGF0Lm9uRXJyb3IoZXZlbnQpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5yZWFkeSkge1xuICAgICAgICB0aGlzLnBsYXllci5wYXVzZVZpZGVvKClcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5wbGF5U3RhdHVzKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnBsYXlPblJlYWR5XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLnBhdXNlKClcbiAgICAgICAgZGVsZXRlIHRoaXMucGxheVN0YXR1c1xuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICAkLmV4dGVuZChnYWxsZXJ5UHJvdG90eXBlLCB7XG4gICAgWW91VHViZVBsYXllcjogWW91VHViZVBsYXllcixcblxuICAgIHRleHRGYWN0b3J5OiBmdW5jdGlvbiAob2JqLCBjYWxsYmFjaykge1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcbiAgICAgIHZhciB2aWRlb0lkID0gdGhpcy5nZXRJdGVtUHJvcGVydHkob2JqLCBvcHRpb25zLnlvdVR1YmVWaWRlb0lkUHJvcGVydHkpXG4gICAgICBpZiAodmlkZW9JZCkge1xuICAgICAgICBpZiAodGhpcy5nZXRJdGVtUHJvcGVydHkob2JqLCBvcHRpb25zLnVybFByb3BlcnR5KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb2JqW29wdGlvbnMudXJsUHJvcGVydHldID0gJy8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9JyArIHZpZGVvSWRcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5nZXRJdGVtUHJvcGVydHkob2JqLCBvcHRpb25zLnZpZGVvUG9zdGVyUHJvcGVydHkpID09PSB1bmRlZmluZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgb2JqW29wdGlvbnMudmlkZW9Qb3N0ZXJQcm9wZXJ0eV0gPVxuICAgICAgICAgICAgJy8vaW1nLnlvdXR1YmUuY29tL3ZpLycgKyB2aWRlb0lkICsgJy9tYXhyZXNkZWZhdWx0LmpwZydcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52aWRlb0ZhY3RvcnkoXG4gICAgICAgICAgb2JqLFxuICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgIG5ldyBZb3VUdWJlUGxheWVyKFxuICAgICAgICAgICAgdmlkZW9JZCxcbiAgICAgICAgICAgIG9wdGlvbnMueW91VHViZVBsYXllclZhcnMsXG4gICAgICAgICAgICBvcHRpb25zLnlvdVR1YmVDbGlja1RvUGxheVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRleHRGYWN0b3J5LmNhbGwodGhpcywgb2JqLCBjYWxsYmFjaylcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIEdhbGxlcnlcbn0pXG4iLCIvKlxuICogYmx1ZWltcCBHYWxsZXJ5IEpTXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9HYWxsZXJ5XG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIFNlYmFzdGlhbiBUc2NoYW5cbiAqIGh0dHBzOi8vYmx1ZWltcC5uZXRcbiAqXG4gKiBTd2lwZSBpbXBsZW1lbnRhdGlvbiBiYXNlZCBvblxuICogaHR0cHM6Ly9naXRodWIuY29tL2JyYWRiaXJkc2FsbC9Td2lwZVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKi9cblxuLyogZ2xvYmFsIGRlZmluZSwgRG9jdW1lbnRUb3VjaCAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuXG47KGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICd1c2Ugc3RyaWN0J1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIEFNRCBtb2R1bGU6XG4gICAgZGVmaW5lKFsnLi9ibHVlaW1wLWhlbHBlciddLCBmYWN0b3J5KVxuICB9IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFsczpcbiAgICB3aW5kb3cuYmx1ZWltcCA9IHdpbmRvdy5ibHVlaW1wIHx8IHt9XG4gICAgd2luZG93LmJsdWVpbXAuR2FsbGVyeSA9IGZhY3Rvcnkod2luZG93LmJsdWVpbXAuaGVscGVyIHx8IHdpbmRvdy5qUXVlcnkpXG4gIH1cbn0pKGZ1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0J1xuXG4gIC8qKlxuICAgKiBHYWxsZXJ5IGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge0FycmF5fE5vZGVMaXN0fSBsaXN0IEdhbGxlcnkgY29udGVudFxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIEdhbGxlcnkgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBHYWxsZXJ5IG9iamVjdFxuICAgKi9cbiAgZnVuY3Rpb24gR2FsbGVyeShsaXN0LCBvcHRpb25zKSB7XG4gICAgaWYgKGRvY3VtZW50LmJvZHkuc3R5bGUubWF4SGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGRvY3VtZW50LmJvZHkuc3R5bGUubWF4SGVpZ2h0IGlzIHVuZGVmaW5lZCBvbiBJRTYgYW5kIGxvd2VyXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICBpZiAoIXRoaXMgfHwgdGhpcy5vcHRpb25zICE9PSBHYWxsZXJ5LnByb3RvdHlwZS5vcHRpb25zKSB7XG4gICAgICAvLyBDYWxsZWQgYXMgZnVuY3Rpb24gaW5zdGVhZCBvZiBhcyBjb25zdHJ1Y3RvcixcbiAgICAgIC8vIHNvIHdlIHNpbXBseSByZXR1cm4gYSBuZXcgaW5zdGFuY2U6XG4gICAgICByZXR1cm4gbmV3IEdhbGxlcnkobGlzdCwgb3B0aW9ucylcbiAgICB9XG4gICAgaWYgKCFsaXN0IHx8ICFsaXN0Lmxlbmd0aCkge1xuICAgICAgdGhpcy5jb25zb2xlLmxvZyhcbiAgICAgICAgJ2JsdWVpbXAgR2FsbGVyeTogTm8gb3IgZW1wdHkgbGlzdCBwcm92aWRlZCBhcyBmaXJzdCBhcmd1bWVudC4nLFxuICAgICAgICBsaXN0XG4gICAgICApXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5saXN0ID0gbGlzdFxuICAgIHRoaXMubnVtID0gbGlzdC5sZW5ndGhcbiAgICB0aGlzLmluaXRPcHRpb25zKG9wdGlvbnMpXG4gICAgdGhpcy5pbml0aWFsaXplKClcbiAgfVxuXG4gICQuZXh0ZW5kKEdhbGxlcnkucHJvdG90eXBlLCB7XG4gICAgb3B0aW9uczoge1xuICAgICAgLy8gVGhlIElkLCBlbGVtZW50IG9yIHF1ZXJ5U2VsZWN0b3Igb2YgdGhlIGdhbGxlcnkgd2lkZ2V0OlxuICAgICAgY29udGFpbmVyOiAnI2JsdWVpbXAtZ2FsbGVyeScsXG4gICAgICAvLyBUaGUgdGFnIG5hbWUsIElkLCBlbGVtZW50IG9yIHF1ZXJ5U2VsZWN0b3Igb2YgdGhlIHNsaWRlcyBjb250YWluZXI6XG4gICAgICBzbGlkZXNDb250YWluZXI6ICdkaXYnLFxuICAgICAgLy8gVGhlIHRhZyBuYW1lLCBJZCwgZWxlbWVudCBvciBxdWVyeVNlbGVjdG9yIG9mIHRoZSB0aXRsZSBlbGVtZW50OlxuICAgICAgdGl0bGVFbGVtZW50OiAnaDMnLFxuICAgICAgLy8gVGhlIGNsYXNzIHRvIGFkZCB3aGVuIHRoZSBnYWxsZXJ5IGlzIHZpc2libGU6XG4gICAgICBkaXNwbGF5Q2xhc3M6ICdibHVlaW1wLWdhbGxlcnktZGlzcGxheScsXG4gICAgICAvLyBUaGUgY2xhc3MgdG8gYWRkIHdoZW4gdGhlIGdhbGxlcnkgY29udHJvbHMgYXJlIHZpc2libGU6XG4gICAgICBjb250cm9sc0NsYXNzOiAnYmx1ZWltcC1nYWxsZXJ5LWNvbnRyb2xzJyxcbiAgICAgIC8vIFRoZSBjbGFzcyB0byBhZGQgd2hlbiB0aGUgZ2FsbGVyeSBvbmx5IGRpc3BsYXlzIG9uZSBlbGVtZW50OlxuICAgICAgc2luZ2xlQ2xhc3M6ICdibHVlaW1wLWdhbGxlcnktc2luZ2xlJyxcbiAgICAgIC8vIFRoZSBjbGFzcyB0byBhZGQgd2hlbiB0aGUgbGVmdCBlZGdlIGhhcyBiZWVuIHJlYWNoZWQ6XG4gICAgICBsZWZ0RWRnZUNsYXNzOiAnYmx1ZWltcC1nYWxsZXJ5LWxlZnQnLFxuICAgICAgLy8gVGhlIGNsYXNzIHRvIGFkZCB3aGVuIHRoZSByaWdodCBlZGdlIGhhcyBiZWVuIHJlYWNoZWQ6XG4gICAgICByaWdodEVkZ2VDbGFzczogJ2JsdWVpbXAtZ2FsbGVyeS1yaWdodCcsXG4gICAgICAvLyBUaGUgY2xhc3MgdG8gYWRkIHdoZW4gdGhlIGF1dG9tYXRpYyBzbGlkZXNob3cgaXMgYWN0aXZlOlxuICAgICAgcGxheWluZ0NsYXNzOiAnYmx1ZWltcC1nYWxsZXJ5LXBsYXlpbmcnLFxuICAgICAgLy8gVGhlIGNsYXNzIGZvciBhbGwgc2xpZGVzOlxuICAgICAgc2xpZGVDbGFzczogJ3NsaWRlJyxcbiAgICAgIC8vIFRoZSBzbGlkZSBjbGFzcyBmb3IgbG9hZGluZyBlbGVtZW50czpcbiAgICAgIHNsaWRlTG9hZGluZ0NsYXNzOiAnc2xpZGUtbG9hZGluZycsXG4gICAgICAvLyBUaGUgc2xpZGUgY2xhc3MgZm9yIGVsZW1lbnRzIHRoYXQgZmFpbGVkIHRvIGxvYWQ6XG4gICAgICBzbGlkZUVycm9yQ2xhc3M6ICdzbGlkZS1lcnJvcicsXG4gICAgICAvLyBUaGUgY2xhc3MgZm9yIHRoZSBjb250ZW50IGVsZW1lbnQgbG9hZGVkIGludG8gZWFjaCBzbGlkZTpcbiAgICAgIHNsaWRlQ29udGVudENsYXNzOiAnc2xpZGUtY29udGVudCcsXG4gICAgICAvLyBUaGUgY2xhc3MgZm9yIHRoZSBcInRvZ2dsZVwiIGNvbnRyb2w6XG4gICAgICB0b2dnbGVDbGFzczogJ3RvZ2dsZScsXG4gICAgICAvLyBUaGUgY2xhc3MgZm9yIHRoZSBcInByZXZcIiBjb250cm9sOlxuICAgICAgcHJldkNsYXNzOiAncHJldicsXG4gICAgICAvLyBUaGUgY2xhc3MgZm9yIHRoZSBcIm5leHRcIiBjb250cm9sOlxuICAgICAgbmV4dENsYXNzOiAnbmV4dCcsXG4gICAgICAvLyBUaGUgY2xhc3MgZm9yIHRoZSBcImNsb3NlXCIgY29udHJvbDpcbiAgICAgIGNsb3NlQ2xhc3M6ICdjbG9zZScsXG4gICAgICAvLyBUaGUgY2xhc3MgZm9yIHRoZSBcInBsYXktcGF1c2VcIiB0b2dnbGUgY29udHJvbDpcbiAgICAgIHBsYXlQYXVzZUNsYXNzOiAncGxheS1wYXVzZScsXG4gICAgICAvLyBUaGUgbGlzdCBvYmplY3QgcHJvcGVydHkgKG9yIGRhdGEgYXR0cmlidXRlKSB3aXRoIHRoZSBvYmplY3QgdHlwZTpcbiAgICAgIHR5cGVQcm9wZXJ0eTogJ3R5cGUnLFxuICAgICAgLy8gVGhlIGxpc3Qgb2JqZWN0IHByb3BlcnR5IChvciBkYXRhIGF0dHJpYnV0ZSkgd2l0aCB0aGUgb2JqZWN0IHRpdGxlOlxuICAgICAgdGl0bGVQcm9wZXJ0eTogJ3RpdGxlJyxcbiAgICAgIC8vIFRoZSBsaXN0IG9iamVjdCBwcm9wZXJ0eSAob3IgZGF0YSBhdHRyaWJ1dGUpIHdpdGggdGhlIG9iamVjdCBhbHQgdGV4dDpcbiAgICAgIGFsdFRleHRQcm9wZXJ0eTogJ2FsdCcsXG4gICAgICAvLyBUaGUgbGlzdCBvYmplY3QgcHJvcGVydHkgKG9yIGRhdGEgYXR0cmlidXRlKSB3aXRoIHRoZSBvYmplY3QgVVJMOlxuICAgICAgdXJsUHJvcGVydHk6ICdocmVmJyxcbiAgICAgIC8vIFRoZSBsaXN0IG9iamVjdCBwcm9wZXJ0eSAob3IgZGF0YSBhdHRyaWJ1dGUpIHdpdGggdGhlIG9iamVjdCBzcmNzZXQgVVJMKHMpOlxuICAgICAgc3Jjc2V0UHJvcGVydHk6ICd1cmxzZXQnLFxuICAgICAgLy8gVGhlIGdhbGxlcnkgbGlzdGVucyBmb3IgdHJhbnNpdGlvbmVuZCBldmVudHMgYmVmb3JlIHRyaWdnZXJpbmcgdGhlXG4gICAgICAvLyBvcGVuZWQgYW5kIGNsb3NlZCBldmVudHMsIHVubGVzcyB0aGUgZm9sbG93aW5nIG9wdGlvbiBpcyBzZXQgdG8gZmFsc2U6XG4gICAgICBkaXNwbGF5VHJhbnNpdGlvbjogdHJ1ZSxcbiAgICAgIC8vIERlZmluZXMgaWYgdGhlIGdhbGxlcnkgc2xpZGVzIGFyZSBjbGVhcmVkIGZyb20gdGhlIGdhbGxlcnkgbW9kYWwsXG4gICAgICAvLyBvciByZXVzZWQgZm9yIHRoZSBuZXh0IGdhbGxlcnkgaW5pdGlhbGl6YXRpb246XG4gICAgICBjbGVhclNsaWRlczogdHJ1ZSxcbiAgICAgIC8vIERlZmluZXMgaWYgaW1hZ2VzIHNob3VsZCBiZSBzdHJldGNoZWQgdG8gZmlsbCB0aGUgYXZhaWxhYmxlIHNwYWNlLFxuICAgICAgLy8gd2hpbGUgbWFpbnRhaW5pbmcgdGhlaXIgYXNwZWN0IHJhdGlvICh3aWxsIG9ubHkgYmUgZW5hYmxlZCBmb3IgYnJvd3NlcnNcbiAgICAgIC8vIHN1cHBvcnRpbmcgYmFja2dyb3VuZC1zaXplPVwiY29udGFpblwiLCB3aGljaCBleGNsdWRlcyBJRSA8IDkpLlxuICAgICAgLy8gU2V0IHRvIFwiY292ZXJcIiwgdG8gbWFrZSBpbWFnZXMgY292ZXIgYWxsIGF2YWlsYWJsZSBzcGFjZSAocmVxdWlyZXNcbiAgICAgIC8vIHN1cHBvcnQgZm9yIGJhY2tncm91bmQtc2l6ZT1cImNvdmVyXCIsIHdoaWNoIGV4Y2x1ZGVzIElFIDwgOSk6XG4gICAgICBzdHJldGNoSW1hZ2VzOiBmYWxzZSxcbiAgICAgIC8vIFRvZ2dsZSB0aGUgY29udHJvbHMgb24gcHJlc3NpbmcgdGhlIFJldHVybiBrZXk6XG4gICAgICB0b2dnbGVDb250cm9sc09uUmV0dXJuOiB0cnVlLFxuICAgICAgLy8gVG9nZ2xlIHRoZSBjb250cm9scyBvbiBzbGlkZSBjbGljazpcbiAgICAgIHRvZ2dsZUNvbnRyb2xzT25TbGlkZUNsaWNrOiB0cnVlLFxuICAgICAgLy8gVG9nZ2xlIHRoZSBhdXRvbWF0aWMgc2xpZGVzaG93IGludGVydmFsIG9uIHByZXNzaW5nIHRoZSBTcGFjZSBrZXk6XG4gICAgICB0b2dnbGVTbGlkZXNob3dPblNwYWNlOiB0cnVlLFxuICAgICAgLy8gTmF2aWdhdGUgdGhlIGdhbGxlcnkgYnkgcHJlc3NpbmcgbGVmdCBhbmQgcmlnaHQgb24gdGhlIGtleWJvYXJkOlxuICAgICAgZW5hYmxlS2V5Ym9hcmROYXZpZ2F0aW9uOiB0cnVlLFxuICAgICAgLy8gQ2xvc2UgdGhlIGdhbGxlcnkgb24gcHJlc3NpbmcgdGhlIEVzYyBrZXk6XG4gICAgICBjbG9zZU9uRXNjYXBlOiB0cnVlLFxuICAgICAgLy8gQ2xvc2UgdGhlIGdhbGxlcnkgd2hlbiBjbGlja2luZyBvbiBhbiBlbXB0eSBzbGlkZSBhcmVhOlxuICAgICAgY2xvc2VPblNsaWRlQ2xpY2s6IHRydWUsXG4gICAgICAvLyBDbG9zZSB0aGUgZ2FsbGVyeSBieSBzd2lwaW5nIHVwIG9yIGRvd246XG4gICAgICBjbG9zZU9uU3dpcGVVcE9yRG93bjogdHJ1ZSxcbiAgICAgIC8vIENsb3NlIHRoZSBnYWxsZXJ5IHdoZW4gVVJMIGNoYW5nZXM6XG4gICAgICBjbG9zZU9uSGFzaENoYW5nZTogdHJ1ZSxcbiAgICAgIC8vIEVtdWxhdGUgdG91Y2ggZXZlbnRzIG9uIG1vdXNlLXBvaW50ZXIgZGV2aWNlcyBzdWNoIGFzIGRlc2t0b3AgYnJvd3NlcnM6XG4gICAgICBlbXVsYXRlVG91Y2hFdmVudHM6IHRydWUsXG4gICAgICAvLyBTdG9wIHRvdWNoIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHVwIHRvIGFuY2VzdG9yIGVsZW1lbnRzIG9mIHRoZSBHYWxsZXJ5OlxuICAgICAgc3RvcFRvdWNoRXZlbnRzUHJvcGFnYXRpb246IGZhbHNlLFxuICAgICAgLy8gSGlkZSB0aGUgcGFnZSBzY3JvbGxiYXJzOlxuICAgICAgaGlkZVBhZ2VTY3JvbGxiYXJzOiB0cnVlLFxuICAgICAgLy8gU3RvcHMgYW55IHRvdWNoZXMgb24gdGhlIGNvbnRhaW5lciBmcm9tIHNjcm9sbGluZyB0aGUgcGFnZTpcbiAgICAgIGRpc2FibGVTY3JvbGw6IHRydWUsXG4gICAgICAvLyBDYXJvdXNlbCBtb2RlIChzaG9ydGN1dCBmb3IgY2Fyb3VzZWwgc3BlY2lmaWMgb3B0aW9ucyk6XG4gICAgICBjYXJvdXNlbDogZmFsc2UsXG4gICAgICAvLyBBbGxvdyBjb250aW51b3VzIG5hdmlnYXRpb24sIG1vdmluZyBmcm9tIGxhc3QgdG8gZmlyc3RcbiAgICAgIC8vIGFuZCBmcm9tIGZpcnN0IHRvIGxhc3Qgc2xpZGU6XG4gICAgICBjb250aW51b3VzOiB0cnVlLFxuICAgICAgLy8gUmVtb3ZlIGVsZW1lbnRzIG91dHNpZGUgb2YgdGhlIHByZWxvYWQgcmFuZ2UgZnJvbSB0aGUgRE9NOlxuICAgICAgdW5sb2FkRWxlbWVudHM6IHRydWUsXG4gICAgICAvLyBTdGFydCB3aXRoIHRoZSBhdXRvbWF0aWMgc2xpZGVzaG93OlxuICAgICAgc3RhcnRTbGlkZXNob3c6IGZhbHNlLFxuICAgICAgLy8gRGVsYXkgaW4gbWlsbGlzZWNvbmRzIGJldHdlZW4gc2xpZGVzIGZvciB0aGUgYXV0b21hdGljIHNsaWRlc2hvdzpcbiAgICAgIHNsaWRlc2hvd0ludGVydmFsOiA1MDAwLFxuICAgICAgLy8gVGhlIGRpcmVjdGlvbiB0aGUgc2xpZGVzIGFyZSBtb3Zpbmc6IGx0cj1MZWZ0VG9SaWdodCBvciBydGw9UmlnaHRUb0xlZnRcbiAgICAgIHNsaWRlc2hvd0RpcmVjdGlvbjogJ2x0cicsXG4gICAgICAvLyBUaGUgc3RhcnRpbmcgaW5kZXggYXMgaW50ZWdlci5cbiAgICAgIC8vIENhbiBhbHNvIGJlIGFuIG9iamVjdCBvZiB0aGUgZ2l2ZW4gbGlzdCxcbiAgICAgIC8vIG9yIGFuIGVxdWFsIG9iamVjdCB3aXRoIHRoZSBzYW1lIHVybCBwcm9wZXJ0eTpcbiAgICAgIGluZGV4OiAwLFxuICAgICAgLy8gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBsb2FkIGFyb3VuZCB0aGUgY3VycmVudCBpbmRleDpcbiAgICAgIHByZWxvYWRSYW5nZTogMixcbiAgICAgIC8vIFRoZSB0cmFuc2l0aW9uIGR1cmF0aW9uIGJldHdlZW4gc2xpZGUgY2hhbmdlcyBpbiBtaWxsaXNlY29uZHM6XG4gICAgICB0cmFuc2l0aW9uRHVyYXRpb246IDMwMCxcbiAgICAgIC8vIFRoZSB0cmFuc2l0aW9uIGR1cmF0aW9uIGZvciBhdXRvbWF0aWMgc2xpZGUgY2hhbmdlcywgc2V0IHRvIGFuIGludGVnZXJcbiAgICAgIC8vIGdyZWF0ZXIgMCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCB0cmFuc2l0aW9uIGR1cmF0aW9uOlxuICAgICAgc2xpZGVzaG93VHJhbnNpdGlvbkR1cmF0aW9uOiA1MDAsXG4gICAgICAvLyBUaGUgZXZlbnQgb2JqZWN0IGZvciB3aGljaCB0aGUgZGVmYXVsdCBhY3Rpb24gd2lsbCBiZSBjYW5jZWxlZFxuICAgICAgLy8gb24gR2FsbGVyeSBpbml0aWFsaXphdGlvbiAoZS5nLiB0aGUgY2xpY2sgZXZlbnQgdG8gb3BlbiB0aGUgR2FsbGVyeSk6XG4gICAgICBldmVudDogdW5kZWZpbmVkLFxuICAgICAgLy8gQ2FsbGJhY2sgZnVuY3Rpb24gZXhlY3V0ZWQgd2hlbiB0aGUgR2FsbGVyeSBpcyBpbml0aWFsaXplZC5cbiAgICAgIC8vIElzIGNhbGxlZCB3aXRoIHRoZSBnYWxsZXJ5IGluc3RhbmNlIGFzIFwidGhpc1wiIG9iamVjdDpcbiAgICAgIG9ub3BlbjogdW5kZWZpbmVkLFxuICAgICAgLy8gQ2FsbGJhY2sgZnVuY3Rpb24gZXhlY3V0ZWQgd2hlbiB0aGUgR2FsbGVyeSBoYXMgYmVlbiBpbml0aWFsaXplZFxuICAgICAgLy8gYW5kIHRoZSBpbml0aWFsaXphdGlvbiB0cmFuc2l0aW9uIGhhcyBiZWVuIGNvbXBsZXRlZC5cbiAgICAgIC8vIElzIGNhbGxlZCB3aXRoIHRoZSBnYWxsZXJ5IGluc3RhbmNlIGFzIFwidGhpc1wiIG9iamVjdDpcbiAgICAgIG9ub3BlbmVkOiB1bmRlZmluZWQsXG4gICAgICAvLyBDYWxsYmFjayBmdW5jdGlvbiBleGVjdXRlZCBvbiBzbGlkZSBjaGFuZ2UuXG4gICAgICAvLyBJcyBjYWxsZWQgd2l0aCB0aGUgZ2FsbGVyeSBpbnN0YW5jZSBhcyBcInRoaXNcIiBvYmplY3QgYW5kIHRoZVxuICAgICAgLy8gY3VycmVudCBpbmRleCBhbmQgc2xpZGUgYXMgYXJndW1lbnRzOlxuICAgICAgb25zbGlkZTogdW5kZWZpbmVkLFxuICAgICAgLy8gQ2FsbGJhY2sgZnVuY3Rpb24gZXhlY3V0ZWQgYWZ0ZXIgdGhlIHNsaWRlIGNoYW5nZSB0cmFuc2l0aW9uLlxuICAgICAgLy8gSXMgY2FsbGVkIHdpdGggdGhlIGdhbGxlcnkgaW5zdGFuY2UgYXMgXCJ0aGlzXCIgb2JqZWN0IGFuZCB0aGVcbiAgICAgIC8vIGN1cnJlbnQgaW5kZXggYW5kIHNsaWRlIGFzIGFyZ3VtZW50czpcbiAgICAgIG9uc2xpZGVlbmQ6IHVuZGVmaW5lZCxcbiAgICAgIC8vIENhbGxiYWNrIGZ1bmN0aW9uIGV4ZWN1dGVkIG9uIHNsaWRlIGNvbnRlbnQgbG9hZC5cbiAgICAgIC8vIElzIGNhbGxlZCB3aXRoIHRoZSBnYWxsZXJ5IGluc3RhbmNlIGFzIFwidGhpc1wiIG9iamVjdCBhbmQgdGhlXG4gICAgICAvLyBzbGlkZSBpbmRleCBhbmQgc2xpZGUgZWxlbWVudCBhcyBhcmd1bWVudHM6XG4gICAgICBvbnNsaWRlY29tcGxldGU6IHVuZGVmaW5lZCxcbiAgICAgIC8vIENhbGxiYWNrIGZ1bmN0aW9uIGV4ZWN1dGVkIHdoZW4gdGhlIEdhbGxlcnkgaXMgYWJvdXQgdG8gYmUgY2xvc2VkLlxuICAgICAgLy8gSXMgY2FsbGVkIHdpdGggdGhlIGdhbGxlcnkgaW5zdGFuY2UgYXMgXCJ0aGlzXCIgb2JqZWN0OlxuICAgICAgb25jbG9zZTogdW5kZWZpbmVkLFxuICAgICAgLy8gQ2FsbGJhY2sgZnVuY3Rpb24gZXhlY3V0ZWQgd2hlbiB0aGUgR2FsbGVyeSBoYXMgYmVlbiBjbG9zZWRcbiAgICAgIC8vIGFuZCB0aGUgY2xvc2luZyB0cmFuc2l0aW9uIGhhcyBiZWVuIGNvbXBsZXRlZC5cbiAgICAgIC8vIElzIGNhbGxlZCB3aXRoIHRoZSBnYWxsZXJ5IGluc3RhbmNlIGFzIFwidGhpc1wiIG9iamVjdDpcbiAgICAgIG9uY2xvc2VkOiB1bmRlZmluZWRcbiAgICB9LFxuXG4gICAgY2Fyb3VzZWxPcHRpb25zOiB7XG4gICAgICBoaWRlUGFnZVNjcm9sbGJhcnM6IGZhbHNlLFxuICAgICAgdG9nZ2xlQ29udHJvbHNPblJldHVybjogZmFsc2UsXG4gICAgICB0b2dnbGVTbGlkZXNob3dPblNwYWNlOiBmYWxzZSxcbiAgICAgIGVuYWJsZUtleWJvYXJkTmF2aWdhdGlvbjogZmFsc2UsXG4gICAgICBjbG9zZU9uRXNjYXBlOiBmYWxzZSxcbiAgICAgIGNsb3NlT25TbGlkZUNsaWNrOiBmYWxzZSxcbiAgICAgIGNsb3NlT25Td2lwZVVwT3JEb3duOiBmYWxzZSxcbiAgICAgIGRpc2FibGVTY3JvbGw6IGZhbHNlLFxuICAgICAgc3RhcnRTbGlkZXNob3c6IHRydWVcbiAgICB9LFxuXG4gICAgY29uc29sZTpcbiAgICAgIHdpbmRvdy5jb25zb2xlICYmIHR5cGVvZiB3aW5kb3cuY29uc29sZS5sb2cgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyB3aW5kb3cuY29uc29sZVxuICAgICAgICA6IHsgbG9nOiBmdW5jdGlvbiAoKSB7fSB9LFxuXG4gICAgLy8gRGV0ZWN0IHRvdWNoLCB0cmFuc2l0aW9uLCB0cmFuc2Zvcm0gYW5kIGJhY2tncm91bmQtc2l6ZSBzdXBwb3J0OlxuICAgIHN1cHBvcnQ6IChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgdmFyIHN1cHBvcnQgPSB7XG4gICAgICAgIHRvdWNoOlxuICAgICAgICAgIHdpbmRvdy5vbnRvdWNoc3RhcnQgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICh3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIERvY3VtZW50VG91Y2gpXG4gICAgICB9XG4gICAgICB2YXIgdHJhbnNpdGlvbnMgPSB7XG4gICAgICAgIHdlYmtpdFRyYW5zaXRpb246IHtcbiAgICAgICAgICBlbmQ6ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgICAgICAgICBwcmVmaXg6ICctd2Via2l0LSdcbiAgICAgICAgfSxcbiAgICAgICAgTW96VHJhbnNpdGlvbjoge1xuICAgICAgICAgIGVuZDogJ3RyYW5zaXRpb25lbmQnLFxuICAgICAgICAgIHByZWZpeDogJy1tb3otJ1xuICAgICAgICB9LFxuICAgICAgICBPVHJhbnNpdGlvbjoge1xuICAgICAgICAgIGVuZDogJ290cmFuc2l0aW9uZW5kJyxcbiAgICAgICAgICBwcmVmaXg6ICctby0nXG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zaXRpb246IHtcbiAgICAgICAgICBlbmQ6ICd0cmFuc2l0aW9uZW5kJyxcbiAgICAgICAgICBwcmVmaXg6ICcnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBwcm9wXG4gICAgICBmb3IgKHByb3AgaW4gdHJhbnNpdGlvbnMpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0cmFuc2l0aW9ucywgcHJvcCkgJiZcbiAgICAgICAgICBlbGVtZW50LnN0eWxlW3Byb3BdICE9PSB1bmRlZmluZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgc3VwcG9ydC50cmFuc2l0aW9uID0gdHJhbnNpdGlvbnNbcHJvcF1cbiAgICAgICAgICBzdXBwb3J0LnRyYW5zaXRpb24ubmFtZSA9IHByb3BcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFRlc3RzIGJyb3dzZXIgc3VwcG9ydFxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBlbGVtZW50VGVzdHMoKSB7XG4gICAgICAgIHZhciB0cmFuc2l0aW9uID0gc3VwcG9ydC50cmFuc2l0aW9uXG4gICAgICAgIHZhciBwcm9wXG4gICAgICAgIHZhciB0cmFuc2xhdGVaXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWxlbWVudClcbiAgICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgICBwcm9wID0gdHJhbnNpdGlvbi5uYW1lLnNsaWNlKDAsIC05KSArICdyYW5zZm9ybSdcbiAgICAgICAgICBpZiAoZWxlbWVudC5zdHlsZVtwcm9wXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gJ3RyYW5zbGF0ZVooMCknXG4gICAgICAgICAgICB0cmFuc2xhdGVaID0gd2luZG93XG4gICAgICAgICAgICAgIC5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpXG4gICAgICAgICAgICAgIC5nZXRQcm9wZXJ0eVZhbHVlKHRyYW5zaXRpb24ucHJlZml4ICsgJ3RyYW5zZm9ybScpXG4gICAgICAgICAgICBzdXBwb3J0LnRyYW5zZm9ybSA9IHtcbiAgICAgICAgICAgICAgcHJlZml4OiB0cmFuc2l0aW9uLnByZWZpeCxcbiAgICAgICAgICAgICAgbmFtZTogcHJvcCxcbiAgICAgICAgICAgICAgdHJhbnNsYXRlOiB0cnVlLFxuICAgICAgICAgICAgICB0cmFuc2xhdGVaOiAhIXRyYW5zbGF0ZVogJiYgdHJhbnNsYXRlWiAhPT0gJ25vbmUnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50LnN0eWxlLmJhY2tncm91bmRTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzdXBwb3J0LmJhY2tncm91bmRTaXplID0ge31cbiAgICAgICAgICBlbGVtZW50LnN0eWxlLmJhY2tncm91bmRTaXplID0gJ2NvbnRhaW4nXG4gICAgICAgICAgc3VwcG9ydC5iYWNrZ3JvdW5kU2l6ZS5jb250YWluID1cbiAgICAgICAgICAgIHdpbmRvd1xuICAgICAgICAgICAgICAuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KVxuICAgICAgICAgICAgICAuZ2V0UHJvcGVydHlWYWx1ZSgnYmFja2dyb3VuZC1zaXplJykgPT09ICdjb250YWluJ1xuICAgICAgICAgIGVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZFNpemUgPSAnY292ZXInXG4gICAgICAgICAgc3VwcG9ydC5iYWNrZ3JvdW5kU2l6ZS5jb3ZlciA9XG4gICAgICAgICAgICB3aW5kb3dcbiAgICAgICAgICAgICAgLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudClcbiAgICAgICAgICAgICAgLmdldFByb3BlcnR5VmFsdWUoJ2JhY2tncm91bmQtc2l6ZScpID09PSAnY292ZXInXG4gICAgICAgIH1cbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbGVtZW50KVxuICAgICAgfVxuICAgICAgaWYgKGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgZWxlbWVudFRlc3RzKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICQoZG9jdW1lbnQpLm9uKCdET01Db250ZW50TG9hZGVkJywgZWxlbWVudFRlc3RzKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN1cHBvcnRcbiAgICAgIC8vIFRlc3QgZWxlbWVudCwgaGFzIHRvIGJlIHN0YW5kYXJkIEhUTUwgYW5kIG11c3Qgbm90IGJlIGhpZGRlblxuICAgICAgLy8gZm9yIHRoZSBDU1MzIHRlc3RzIHVzaW5nIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlIHRvIGJlIGFwcGxpY2FibGU6XG4gICAgfSkoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpLFxuXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lOlxuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSxcblxuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lOlxuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICB3aW5kb3cud2Via2l0Q2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgIHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuaW5pdFN0YXJ0SW5kZXgoKVxuICAgICAgaWYgKHRoaXMuaW5pdFdpZGdldCgpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5pdEV2ZW50TGlzdGVuZXJzKClcbiAgICAgIC8vIExvYWQgdGhlIHNsaWRlIGF0IHRoZSBnaXZlbiBpbmRleDpcbiAgICAgIHRoaXMub25zbGlkZSh0aGlzLmluZGV4KVxuICAgICAgLy8gTWFudWFsbHkgdHJpZ2dlciB0aGUgc2xpZGVlbmQgZXZlbnQgZm9yIHRoZSBpbml0aWFsIHNsaWRlOlxuICAgICAgdGhpcy5vbnRyYW5zaXRpb25lbmQoKVxuICAgICAgLy8gU3RhcnQgdGhlIGF1dG9tYXRpYyBzbGlkZXNob3cgaWYgYXBwbGljYWJsZTpcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RhcnRTbGlkZXNob3cpIHtcbiAgICAgICAgdGhpcy5wbGF5KClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2xpZGU6IGZ1bmN0aW9uICh0bywgZHVyYXRpb24pIHtcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KVxuICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleFxuICAgICAgdmFyIGRpcmVjdGlvblxuICAgICAgdmFyIG5hdHVyYWxEaXJlY3Rpb25cbiAgICAgIHZhciBkaWZmXG4gICAgICBpZiAoaW5kZXggPT09IHRvIHx8IHRoaXMubnVtID09PSAxKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgaWYgKCFkdXJhdGlvbikge1xuICAgICAgICBkdXJhdGlvbiA9IHRoaXMub3B0aW9ucy50cmFuc2l0aW9uRHVyYXRpb25cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN1cHBvcnQudHJhbnNmb3JtKSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmNvbnRpbnVvdXMpIHtcbiAgICAgICAgICB0byA9IHRoaXMuY2lyY2xlKHRvKVxuICAgICAgICB9XG4gICAgICAgIC8vIDE6IGJhY2t3YXJkLCAtMTogZm9yd2FyZDpcbiAgICAgICAgZGlyZWN0aW9uID0gTWF0aC5hYnMoaW5kZXggLSB0bykgLyAoaW5kZXggLSB0bylcbiAgICAgICAgLy8gR2V0IHRoZSBhY3R1YWwgcG9zaXRpb24gb2YgdGhlIHNsaWRlOlxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvbnRpbnVvdXMpIHtcbiAgICAgICAgICBuYXR1cmFsRGlyZWN0aW9uID0gZGlyZWN0aW9uXG4gICAgICAgICAgZGlyZWN0aW9uID0gLXRoaXMucG9zaXRpb25zW3RoaXMuY2lyY2xlKHRvKV0gLyB0aGlzLnNsaWRlV2lkdGhcbiAgICAgICAgICAvLyBJZiBnb2luZyBmb3J3YXJkIGJ1dCB0byA8IGluZGV4LCB1c2UgdG8gPSBzbGlkZXMubGVuZ3RoICsgdG9cbiAgICAgICAgICAvLyBJZiBnb2luZyBiYWNrd2FyZCBidXQgdG8gPiBpbmRleCwgdXNlIHRvID0gLXNsaWRlcy5sZW5ndGggKyB0b1xuICAgICAgICAgIGlmIChkaXJlY3Rpb24gIT09IG5hdHVyYWxEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHRvID0gLWRpcmVjdGlvbiAqIHRoaXMubnVtICsgdG9cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGlmZiA9IE1hdGguYWJzKGluZGV4IC0gdG8pIC0gMVxuICAgICAgICAvLyBNb3ZlIGFsbCB0aGUgc2xpZGVzIGJldHdlZW4gaW5kZXggYW5kIHRvIGluIHRoZSByaWdodCBkaXJlY3Rpb246XG4gICAgICAgIHdoaWxlIChkaWZmKSB7XG4gICAgICAgICAgZGlmZiAtPSAxXG4gICAgICAgICAgdGhpcy5tb3ZlKFxuICAgICAgICAgICAgdGhpcy5jaXJjbGUoKHRvID4gaW5kZXggPyB0byA6IGluZGV4KSAtIGRpZmYgLSAxKSxcbiAgICAgICAgICAgIHRoaXMuc2xpZGVXaWR0aCAqIGRpcmVjdGlvbixcbiAgICAgICAgICAgIDBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgdG8gPSB0aGlzLmNpcmNsZSh0bylcbiAgICAgICAgdGhpcy5tb3ZlKGluZGV4LCB0aGlzLnNsaWRlV2lkdGggKiBkaXJlY3Rpb24sIGR1cmF0aW9uKVxuICAgICAgICB0aGlzLm1vdmUodG8sIDAsIGR1cmF0aW9uKVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvbnRpbnVvdXMpIHtcbiAgICAgICAgICB0aGlzLm1vdmUoXG4gICAgICAgICAgICB0aGlzLmNpcmNsZSh0byAtIGRpcmVjdGlvbiksXG4gICAgICAgICAgICAtKHRoaXMuc2xpZGVXaWR0aCAqIGRpcmVjdGlvbiksXG4gICAgICAgICAgICAwXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0byA9IHRoaXMuY2lyY2xlKHRvKVxuICAgICAgICB0aGlzLmFuaW1hdGUoaW5kZXggKiAtdGhpcy5zbGlkZVdpZHRoLCB0byAqIC10aGlzLnNsaWRlV2lkdGgsIGR1cmF0aW9uKVxuICAgICAgfVxuICAgICAgdGhpcy5vbnNsaWRlKHRvKVxuICAgIH0sXG5cbiAgICBnZXRJbmRleDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZXhcbiAgICB9LFxuXG4gICAgZ2V0TnVtYmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5udW1cbiAgICB9LFxuXG4gICAgcHJldjogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250aW51b3VzIHx8IHRoaXMuaW5kZXgpIHtcbiAgICAgICAgdGhpcy5zbGlkZSh0aGlzLmluZGV4IC0gMSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250aW51b3VzIHx8IHRoaXMuaW5kZXggPCB0aGlzLm51bSAtIDEpIHtcbiAgICAgICAgdGhpcy5zbGlkZSh0aGlzLmluZGV4ICsgMSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcGxheTogZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICAgdmFyIG5leHRJbmRleCA9XG4gICAgICAgIHRoaXMuaW5kZXggKyAodGhpcy5vcHRpb25zLnNsaWRlc2hvd0RpcmVjdGlvbiA9PT0gJ3J0bCcgPyAtMSA6IDEpXG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dClcbiAgICAgIHRoaXMuaW50ZXJ2YWwgPSB0aW1lIHx8IHRoaXMub3B0aW9ucy5zbGlkZXNob3dJbnRlcnZhbFxuICAgICAgaWYgKHRoaXMuZWxlbWVudHNbdGhpcy5pbmRleF0gPiAxKSB7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHRoaXMuc2V0VGltZW91dChcbiAgICAgICAgICAoIXRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lICYmIHRoaXMuc2xpZGUpIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAodG8sIGR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgIHRoYXQuYW5pbWF0aW9uRnJhbWVJZCA9IHRoYXQucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmNhbGwoXG4gICAgICAgICAgICAgICAgd2luZG93LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHRoYXQuc2xpZGUodG8sIGR1cmF0aW9uKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICBbbmV4dEluZGV4LCB0aGlzLm9wdGlvbnMuc2xpZGVzaG93VHJhbnNpdGlvbkR1cmF0aW9uXSxcbiAgICAgICAgICB0aGlzLmludGVydmFsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIHRoaXMuY29udGFpbmVyLmFkZENsYXNzKHRoaXMub3B0aW9ucy5wbGF5aW5nQ2xhc3MpXG4gICAgfSxcblxuICAgIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dClcbiAgICAgIHRoaXMuaW50ZXJ2YWwgPSBudWxsXG4gICAgICBpZiAodGhpcy5jYW5jZWxBbmltYXRpb25GcmFtZSkge1xuICAgICAgICB0aGlzLmNhbmNlbEFuaW1hdGlvbkZyYW1lLmNhbGwod2luZG93LCB0aGlzLmFuaW1hdGlvbkZyYW1lSWQpXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uRnJhbWVJZCA9IG51bGxcbiAgICAgIH1cbiAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5wbGF5aW5nQ2xhc3MpXG4gICAgfSxcblxuICAgIGFkZDogZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgIHZhciBpXG4gICAgICBpZiAoIWxpc3QuY29uY2F0KSB7XG4gICAgICAgIC8vIE1ha2UgYSByZWFsIGFycmF5IG91dCBvZiB0aGUgbGlzdCB0byBhZGQ6XG4gICAgICAgIGxpc3QgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0KVxuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmxpc3QuY29uY2F0KSB7XG4gICAgICAgIC8vIE1ha2UgYSByZWFsIGFycmF5IG91dCBvZiB0aGUgR2FsbGVyeSBsaXN0OlxuICAgICAgICB0aGlzLmxpc3QgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLmxpc3QpXG4gICAgICB9XG4gICAgICB0aGlzLmxpc3QgPSB0aGlzLmxpc3QuY29uY2F0KGxpc3QpXG4gICAgICB0aGlzLm51bSA9IHRoaXMubGlzdC5sZW5ndGhcbiAgICAgIGlmICh0aGlzLm51bSA+IDIgJiYgdGhpcy5vcHRpb25zLmNvbnRpbnVvdXMgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmNvbnRpbnVvdXMgPSB0cnVlXG4gICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5sZWZ0RWRnZUNsYXNzKVxuICAgICAgfVxuICAgICAgdGhpcy5jb250YWluZXJcbiAgICAgICAgLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5yaWdodEVkZ2VDbGFzcylcbiAgICAgICAgLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5zaW5nbGVDbGFzcylcbiAgICAgIGZvciAoaSA9IHRoaXMubnVtIC0gbGlzdC5sZW5ndGg7IGkgPCB0aGlzLm51bTsgaSArPSAxKSB7XG4gICAgICAgIHRoaXMuYWRkU2xpZGUoaSlcbiAgICAgICAgdGhpcy5wb3NpdGlvblNsaWRlKGkpXG4gICAgICB9XG4gICAgICB0aGlzLnBvc2l0aW9ucy5sZW5ndGggPSB0aGlzLm51bVxuICAgICAgdGhpcy5pbml0U2xpZGVzKHRydWUpXG4gICAgfSxcblxuICAgIHJlc2V0U2xpZGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnNsaWRlc0NvbnRhaW5lci5lbXB0eSgpXG4gICAgICB0aGlzLnVubG9hZEFsbFNsaWRlcygpXG4gICAgICB0aGlzLnNsaWRlcyA9IFtdXG4gICAgfSxcblxuICAgIGhhbmRsZUNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuICAgICAgdGhpcy5kZXN0cm95RXZlbnRMaXN0ZW5lcnMoKVxuICAgICAgLy8gQ2FuY2VsIHRoZSBzbGlkZXNob3c6XG4gICAgICB0aGlzLnBhdXNlKClcbiAgICAgIHRoaXMuY29udGFpbmVyWzBdLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgIHRoaXMuY29udGFpbmVyXG4gICAgICAgIC5yZW1vdmVDbGFzcyhvcHRpb25zLmRpc3BsYXlDbGFzcylcbiAgICAgICAgLnJlbW92ZUNsYXNzKG9wdGlvbnMuc2luZ2xlQ2xhc3MpXG4gICAgICAgIC5yZW1vdmVDbGFzcyhvcHRpb25zLmxlZnRFZGdlQ2xhc3MpXG4gICAgICAgIC5yZW1vdmVDbGFzcyhvcHRpb25zLnJpZ2h0RWRnZUNsYXNzKVxuICAgICAgaWYgKG9wdGlvbnMuaGlkZVBhZ2VTY3JvbGxiYXJzKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSB0aGlzLmJvZHlPdmVyZmxvd1N0eWxlXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNsZWFyU2xpZGVzKSB7XG4gICAgICAgIHRoaXMucmVzZXRTbGlkZXMoKVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vbmNsb3NlZCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25jbG9zZWQuY2FsbCh0aGlzKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgICAvKipcbiAgICAgICAqIENsb3NlIGhhbmRsZXJcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge2V2ZW50fSBldmVudCBDbG9zZSBldmVudFxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBjbG9zZUhhbmRsZXIoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhhdC5jb250YWluZXJbMF0pIHtcbiAgICAgICAgICB0aGF0LmNvbnRhaW5lci5vZmYodGhhdC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kLCBjbG9zZUhhbmRsZXIpXG4gICAgICAgICAgdGhhdC5oYW5kbGVDbG9zZSgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub25jbG9zZSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25jbG9zZS5jYWxsKHRoaXMpXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdXBwb3J0LnRyYW5zaXRpb24gJiYgdGhpcy5vcHRpb25zLmRpc3BsYXlUcmFuc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLm9uKHRoaXMuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCwgY2xvc2VIYW5kbGVyKVxuICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuZGlzcGxheUNsYXNzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVDbG9zZSgpXG4gICAgICB9XG4gICAgfSxcblxuICAgIGNpcmNsZTogZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAvLyBBbHdheXMgcmV0dXJuIGEgbnVtYmVyIGluc2lkZSBvZiB0aGUgc2xpZGVzIGluZGV4IHJhbmdlOlxuICAgICAgcmV0dXJuICh0aGlzLm51bSArIChpbmRleCAlIHRoaXMubnVtKSkgJSB0aGlzLm51bVxuICAgIH0sXG5cbiAgICBtb3ZlOiBmdW5jdGlvbiAoaW5kZXgsIGRpc3QsIGR1cmF0aW9uKSB7XG4gICAgICB0aGlzLnRyYW5zbGF0ZVgoaW5kZXgsIGRpc3QsIGR1cmF0aW9uKVxuICAgICAgdGhpcy5wb3NpdGlvbnNbaW5kZXhdID0gZGlzdFxuICAgIH0sXG5cbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uIChpbmRleCwgeCwgeSwgZHVyYXRpb24pIHtcbiAgICAgIGlmICghdGhpcy5zbGlkZXNbaW5kZXhdKSByZXR1cm5cbiAgICAgIHZhciBzdHlsZSA9IHRoaXMuc2xpZGVzW2luZGV4XS5zdHlsZVxuICAgICAgdmFyIHRyYW5zaXRpb24gPSB0aGlzLnN1cHBvcnQudHJhbnNpdGlvblxuICAgICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMuc3VwcG9ydC50cmFuc2Zvcm1cbiAgICAgIHN0eWxlW3RyYW5zaXRpb24ubmFtZSArICdEdXJhdGlvbiddID0gZHVyYXRpb24gKyAnbXMnXG4gICAgICBzdHlsZVt0cmFuc2Zvcm0ubmFtZV0gPVxuICAgICAgICAndHJhbnNsYXRlKCcgK1xuICAgICAgICB4ICtcbiAgICAgICAgJ3B4LCAnICtcbiAgICAgICAgeSArXG4gICAgICAgICdweCknICtcbiAgICAgICAgKHRyYW5zZm9ybS50cmFuc2xhdGVaID8gJyB0cmFuc2xhdGVaKDApJyA6ICcnKVxuICAgIH0sXG5cbiAgICB0cmFuc2xhdGVYOiBmdW5jdGlvbiAoaW5kZXgsIHgsIGR1cmF0aW9uKSB7XG4gICAgICB0aGlzLnRyYW5zbGF0ZShpbmRleCwgeCwgMCwgZHVyYXRpb24pXG4gICAgfSxcblxuICAgIHRyYW5zbGF0ZVk6IGZ1bmN0aW9uIChpbmRleCwgeSwgZHVyYXRpb24pIHtcbiAgICAgIHRoaXMudHJhbnNsYXRlKGluZGV4LCAwLCB5LCBkdXJhdGlvbilcbiAgICB9LFxuXG4gICAgYW5pbWF0ZTogZnVuY3Rpb24gKGZyb20sIHRvLCBkdXJhdGlvbikge1xuICAgICAgaWYgKCFkdXJhdGlvbikge1xuICAgICAgICB0aGlzLnNsaWRlc0NvbnRhaW5lclswXS5zdHlsZS5sZWZ0ID0gdG8gKyAncHgnXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgICB2YXIgc3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICAgICAgdmFyIHRpbWVyID0gd2luZG93LnNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRpbWVFbGFwID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydFxuICAgICAgICBpZiAodGltZUVsYXAgPiBkdXJhdGlvbikge1xuICAgICAgICAgIHRoYXQuc2xpZGVzQ29udGFpbmVyWzBdLnN0eWxlLmxlZnQgPSB0byArICdweCdcbiAgICAgICAgICB0aGF0Lm9udHJhbnNpdGlvbmVuZCgpXG4gICAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGltZXIpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5zbGlkZXNDb250YWluZXJbMF0uc3R5bGUubGVmdCA9XG4gICAgICAgICAgKHRvIC0gZnJvbSkgKiAoTWF0aC5mbG9vcigodGltZUVsYXAgLyBkdXJhdGlvbikgKiAxMDApIC8gMTAwKSArXG4gICAgICAgICAgZnJvbSArXG4gICAgICAgICAgJ3B4J1xuICAgICAgfSwgNClcbiAgICB9LFxuXG4gICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2VcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWVcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb25yZXNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuaW5pdFNsaWRlcyh0cnVlKVxuICAgIH0sXG5cbiAgICBvbmhhc2hjaGFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkhhc2hDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICB9XG4gICAgfSxcblxuICAgIG9ubW91c2Vkb3duOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIC8vIFRyaWdnZXIgb24gY2xpY2tzIG9mIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBvbmx5XG4gICAgICAvLyBhbmQgZXhjbHVkZSB2aWRlbyAmIGF1ZGlvIGVsZW1lbnRzOlxuICAgICAgaWYgKFxuICAgICAgICBldmVudC53aGljaCAmJlxuICAgICAgICBldmVudC53aGljaCA9PT0gMSAmJlxuICAgICAgICBldmVudC50YXJnZXQubm9kZU5hbWUgIT09ICdWSURFTycgJiZcbiAgICAgICAgZXZlbnQudGFyZ2V0Lm5vZGVOYW1lICE9PSAnQVVESU8nXG4gICAgICApIHtcbiAgICAgICAgLy8gUHJldmVudGluZyB0aGUgZGVmYXVsdCBtb3VzZWRvd24gYWN0aW9uIGlzIHJlcXVpcmVkXG4gICAgICAgIC8vIHRvIG1ha2UgdG91Y2ggZW11bGF0aW9uIHdvcmsgd2l0aCBGaXJlZm94OlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIDsoZXZlbnQub3JpZ2luYWxFdmVudCB8fCBldmVudCkudG91Y2hlcyA9IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwYWdlWDogZXZlbnQucGFnZVgsXG4gICAgICAgICAgICBwYWdlWTogZXZlbnQucGFnZVlcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgICAgdGhpcy5vbnRvdWNoc3RhcnQoZXZlbnQpXG4gICAgICB9XG4gICAgfSxcblxuICAgIG9ubW91c2Vtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmICh0aGlzLnRvdWNoU3RhcnQpIHtcbiAgICAgICAgOyhldmVudC5vcmlnaW5hbEV2ZW50IHx8IGV2ZW50KS50b3VjaGVzID0gW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHBhZ2VYOiBldmVudC5wYWdlWCxcbiAgICAgICAgICAgIHBhZ2VZOiBldmVudC5wYWdlWVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgICB0aGlzLm9udG91Y2htb3ZlKGV2ZW50KVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBvbm1vdXNldXA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKHRoaXMudG91Y2hTdGFydCkge1xuICAgICAgICB0aGlzLm9udG91Y2hlbmQoZXZlbnQpXG4gICAgICAgIGRlbGV0ZSB0aGlzLnRvdWNoU3RhcnRcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb25tb3VzZW91dDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAodGhpcy50b3VjaFN0YXJ0KSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXRcbiAgICAgICAgdmFyIHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0XG4gICAgICAgIGlmICghcmVsYXRlZCB8fCAocmVsYXRlZCAhPT0gdGFyZ2V0ICYmICEkLmNvbnRhaW5zKHRhcmdldCwgcmVsYXRlZCkpKSB7XG4gICAgICAgICAgdGhpcy5vbm1vdXNldXAoZXZlbnQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb250b3VjaHN0YXJ0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RvcFRvdWNoRXZlbnRzUHJvcGFnYXRpb24pIHtcbiAgICAgICAgdGhpcy5zdG9wUHJvcGFnYXRpb24oZXZlbnQpXG4gICAgICB9XG4gICAgICAvLyBqUXVlcnkgZG9lc24ndCBjb3B5IHRvdWNoIGV2ZW50IHByb3BlcnRpZXMgYnkgZGVmYXVsdCxcbiAgICAgIC8vIHNvIHdlIGhhdmUgdG8gYWNjZXNzIHRoZSBvcmlnaW5hbEV2ZW50IG9iamVjdDpcbiAgICAgIHZhciB0b3VjaCA9IChldmVudC5vcmlnaW5hbEV2ZW50IHx8IGV2ZW50KS50b3VjaGVzWzBdXG4gICAgICB0aGlzLnRvdWNoU3RhcnQgPSB7XG4gICAgICAgIC8vIFJlbWVtYmVyIHRoZSBpbml0aWFsIHRvdWNoIGNvb3JkaW5hdGVzOlxuICAgICAgICB4OiB0b3VjaC5wYWdlWCxcbiAgICAgICAgeTogdG91Y2gucGFnZVksXG4gICAgICAgIC8vIFN0b3JlIHRoZSB0aW1lIHRvIGRldGVybWluZSB0b3VjaCBkdXJhdGlvbjpcbiAgICAgICAgdGltZTogRGF0ZS5ub3coKVxuICAgICAgfVxuICAgICAgLy8gSGVscGVyIHZhcmlhYmxlIHRvIGRldGVjdCBzY3JvbGwgbW92ZW1lbnQ6XG4gICAgICB0aGlzLmlzU2Nyb2xsaW5nID0gdW5kZWZpbmVkXG4gICAgICAvLyBSZXNldCBkZWx0YSB2YWx1ZXM6XG4gICAgICB0aGlzLnRvdWNoRGVsdGEgPSB7fVxuICAgIH0sXG5cbiAgICBvbnRvdWNobW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnN0b3BUb3VjaEV2ZW50c1Byb3BhZ2F0aW9uKSB7XG4gICAgICAgIHRoaXMuc3RvcFByb3BhZ2F0aW9uKGV2ZW50KVxuICAgICAgfVxuICAgICAgLy8galF1ZXJ5IGRvZXNuJ3QgY29weSB0b3VjaCBldmVudCBwcm9wZXJ0aWVzIGJ5IGRlZmF1bHQsXG4gICAgICAvLyBzbyB3ZSBoYXZlIHRvIGFjY2VzcyB0aGUgb3JpZ2luYWxFdmVudCBvYmplY3Q6XG4gICAgICB2YXIgdG91Y2hlcyA9IChldmVudC5vcmlnaW5hbEV2ZW50IHx8IGV2ZW50KS50b3VjaGVzXG4gICAgICB2YXIgdG91Y2ggPSB0b3VjaGVzWzBdXG4gICAgICB2YXIgc2NhbGUgPSAoZXZlbnQub3JpZ2luYWxFdmVudCB8fCBldmVudCkuc2NhbGVcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXhcbiAgICAgIHZhciB0b3VjaERlbHRhWFxuICAgICAgdmFyIGluZGljZXNcbiAgICAgIC8vIEVuc3VyZSB0aGlzIGlzIGEgb25lIHRvdWNoIHN3aXBlIGFuZCBub3QsIGUuZy4gYSBwaW5jaDpcbiAgICAgIGlmICh0b3VjaGVzLmxlbmd0aCA+IDEgfHwgKHNjYWxlICYmIHNjYWxlICE9PSAxKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzYWJsZVNjcm9sbCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICB9XG4gICAgICAvLyBNZWFzdXJlIGNoYW5nZSBpbiB4IGFuZCB5IGNvb3JkaW5hdGVzOlxuICAgICAgdGhpcy50b3VjaERlbHRhID0ge1xuICAgICAgICB4OiB0b3VjaC5wYWdlWCAtIHRoaXMudG91Y2hTdGFydC54LFxuICAgICAgICB5OiB0b3VjaC5wYWdlWSAtIHRoaXMudG91Y2hTdGFydC55XG4gICAgICB9XG4gICAgICB0b3VjaERlbHRhWCA9IHRoaXMudG91Y2hEZWx0YS54XG4gICAgICAvLyBEZXRlY3QgaWYgdGhpcyBpcyBhIHZlcnRpY2FsIHNjcm9sbCBtb3ZlbWVudCAocnVuIG9ubHkgb25jZSBwZXIgdG91Y2gpOlxuICAgICAgaWYgKHRoaXMuaXNTY3JvbGxpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmlzU2Nyb2xsaW5nID1cbiAgICAgICAgICB0aGlzLmlzU2Nyb2xsaW5nIHx8XG4gICAgICAgICAgTWF0aC5hYnModG91Y2hEZWx0YVgpIDwgTWF0aC5hYnModGhpcy50b3VjaERlbHRhLnkpXG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuaXNTY3JvbGxpbmcpIHtcbiAgICAgICAgLy8gQWx3YXlzIHByZXZlbnQgaG9yaXpvbnRhbCBzY3JvbGw6XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgLy8gU3RvcCB0aGUgc2xpZGVzaG93OlxuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dClcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250aW51b3VzKSB7XG4gICAgICAgICAgaW5kaWNlcyA9IFt0aGlzLmNpcmNsZShpbmRleCArIDEpLCBpbmRleCwgdGhpcy5jaXJjbGUoaW5kZXggLSAxKV1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJbmNyZWFzZSByZXNpc3RhbmNlIGlmIGZpcnN0IHNsaWRlIGFuZCBzbGlkaW5nIGxlZnRcbiAgICAgICAgICAvLyBvciBsYXN0IHNsaWRlIGFuZCBzbGlkaW5nIHJpZ2h0OlxuICAgICAgICAgIHRoaXMudG91Y2hEZWx0YS54ID0gdG91Y2hEZWx0YVggPVxuICAgICAgICAgICAgdG91Y2hEZWx0YVggL1xuICAgICAgICAgICAgKCghaW5kZXggJiYgdG91Y2hEZWx0YVggPiAwKSB8fFxuICAgICAgICAgICAgKGluZGV4ID09PSB0aGlzLm51bSAtIDEgJiYgdG91Y2hEZWx0YVggPCAwKVxuICAgICAgICAgICAgICA/IE1hdGguYWJzKHRvdWNoRGVsdGFYKSAvIHRoaXMuc2xpZGVXaWR0aCArIDFcbiAgICAgICAgICAgICAgOiAxKVxuICAgICAgICAgIGluZGljZXMgPSBbaW5kZXhdXG4gICAgICAgICAgaWYgKGluZGV4KSB7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2goaW5kZXggLSAxKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5kZXggPCB0aGlzLm51bSAtIDEpIHtcbiAgICAgICAgICAgIGluZGljZXMudW5zaGlmdChpbmRleCArIDEpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpbmRpY2VzLmxlbmd0aCkge1xuICAgICAgICAgIGluZGV4ID0gaW5kaWNlcy5wb3AoKVxuICAgICAgICAgIHRoaXMudHJhbnNsYXRlWChpbmRleCwgdG91Y2hEZWx0YVggKyB0aGlzLnBvc2l0aW9uc1tpbmRleF0sIDApXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMub3B0aW9ucy5jYXJvdXNlbCkge1xuICAgICAgICB0aGlzLnRyYW5zbGF0ZVkoaW5kZXgsIHRoaXMudG91Y2hEZWx0YS55ICsgdGhpcy5wb3NpdGlvbnNbaW5kZXhdLCAwKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBvbnRvdWNoZW5kOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RvcFRvdWNoRXZlbnRzUHJvcGFnYXRpb24pIHtcbiAgICAgICAgdGhpcy5zdG9wUHJvcGFnYXRpb24oZXZlbnQpXG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4XG4gICAgICB2YXIgYWJzVG91Y2hEZWx0YVggPSBNYXRoLmFicyh0aGlzLnRvdWNoRGVsdGEueClcbiAgICAgIHZhciBzbGlkZVdpZHRoID0gdGhpcy5zbGlkZVdpZHRoXG4gICAgICB2YXIgZHVyYXRpb24gPSBNYXRoLmNlaWwoXG4gICAgICAgICh0aGlzLm9wdGlvbnMudHJhbnNpdGlvbkR1cmF0aW9uICogKDEgLSBhYnNUb3VjaERlbHRhWCAvIHNsaWRlV2lkdGgpKSAvXG4gICAgICAgICAgMlxuICAgICAgKVxuICAgICAgLy8gRGV0ZXJtaW5lIGlmIHNsaWRlIGF0dGVtcHQgdHJpZ2dlcnMgbmV4dC9wcmV2IHNsaWRlOlxuICAgICAgdmFyIGlzVmFsaWRTbGlkZSA9IGFic1RvdWNoRGVsdGFYID4gMjBcbiAgICAgIC8vIERldGVybWluZSBpZiBzbGlkZSBhdHRlbXB0IGlzIHBhc3Qgc3RhcnQgb3IgZW5kOlxuICAgICAgdmFyIGlzUGFzdEJvdW5kcyA9XG4gICAgICAgICghaW5kZXggJiYgdGhpcy50b3VjaERlbHRhLnggPiAwKSB8fFxuICAgICAgICAoaW5kZXggPT09IHRoaXMubnVtIC0gMSAmJiB0aGlzLnRvdWNoRGVsdGEueCA8IDApXG4gICAgICB2YXIgaXNWYWxpZENsb3NlID1cbiAgICAgICAgIWlzVmFsaWRTbGlkZSAmJlxuICAgICAgICB0aGlzLm9wdGlvbnMuY2xvc2VPblN3aXBlVXBPckRvd24gJiZcbiAgICAgICAgTWF0aC5hYnModGhpcy50b3VjaERlbHRhLnkpID4gMjBcbiAgICAgIHZhciBkaXJlY3Rpb25cbiAgICAgIHZhciBpbmRleEZvcndhcmRcbiAgICAgIHZhciBpbmRleEJhY2t3YXJkXG4gICAgICB2YXIgZGlzdGFuY2VGb3J3YXJkXG4gICAgICB2YXIgZGlzdGFuY2VCYWNrd2FyZFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250aW51b3VzKSB7XG4gICAgICAgIGlzUGFzdEJvdW5kcyA9IGZhbHNlXG4gICAgICB9XG4gICAgICAvLyBEZXRlcm1pbmUgZGlyZWN0aW9uIG9mIHN3aXBlICh0cnVlOiByaWdodCwgZmFsc2U6IGxlZnQpOlxuICAgICAgZGlyZWN0aW9uID0gdGhpcy50b3VjaERlbHRhLnggPCAwID8gLTEgOiAxXG4gICAgICBpZiAoIXRoaXMuaXNTY3JvbGxpbmcpIHtcbiAgICAgICAgaWYgKGlzVmFsaWRTbGlkZSAmJiAhaXNQYXN0Qm91bmRzKSB7XG4gICAgICAgICAgaW5kZXhGb3J3YXJkID0gaW5kZXggKyBkaXJlY3Rpb25cbiAgICAgICAgICBpbmRleEJhY2t3YXJkID0gaW5kZXggLSBkaXJlY3Rpb25cbiAgICAgICAgICBkaXN0YW5jZUZvcndhcmQgPSBzbGlkZVdpZHRoICogZGlyZWN0aW9uXG4gICAgICAgICAgZGlzdGFuY2VCYWNrd2FyZCA9IC1zbGlkZVdpZHRoICogZGlyZWN0aW9uXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250aW51b3VzKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmUodGhpcy5jaXJjbGUoaW5kZXhGb3J3YXJkKSwgZGlzdGFuY2VGb3J3YXJkLCAwKVxuICAgICAgICAgICAgdGhpcy5tb3ZlKHRoaXMuY2lyY2xlKGluZGV4IC0gMiAqIGRpcmVjdGlvbiksIGRpc3RhbmNlQmFja3dhcmQsIDApXG4gICAgICAgICAgfSBlbHNlIGlmIChpbmRleEZvcndhcmQgPj0gMCAmJiBpbmRleEZvcndhcmQgPCB0aGlzLm51bSkge1xuICAgICAgICAgICAgdGhpcy5tb3ZlKGluZGV4Rm9yd2FyZCwgZGlzdGFuY2VGb3J3YXJkLCAwKVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm1vdmUoaW5kZXgsIHRoaXMucG9zaXRpb25zW2luZGV4XSArIGRpc3RhbmNlRm9yd2FyZCwgZHVyYXRpb24pXG4gICAgICAgICAgdGhpcy5tb3ZlKFxuICAgICAgICAgICAgdGhpcy5jaXJjbGUoaW5kZXhCYWNrd2FyZCksXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uc1t0aGlzLmNpcmNsZShpbmRleEJhY2t3YXJkKV0gKyBkaXN0YW5jZUZvcndhcmQsXG4gICAgICAgICAgICBkdXJhdGlvblxuICAgICAgICAgIClcbiAgICAgICAgICBpbmRleCA9IHRoaXMuY2lyY2xlKGluZGV4QmFja3dhcmQpXG4gICAgICAgICAgdGhpcy5vbnNsaWRlKGluZGV4KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE1vdmUgYmFjayBpbnRvIHBvc2l0aW9uXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250aW51b3VzKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmUodGhpcy5jaXJjbGUoaW5kZXggLSAxKSwgLXNsaWRlV2lkdGgsIGR1cmF0aW9uKVxuICAgICAgICAgICAgdGhpcy5tb3ZlKGluZGV4LCAwLCBkdXJhdGlvbilcbiAgICAgICAgICAgIHRoaXMubW92ZSh0aGlzLmNpcmNsZShpbmRleCArIDEpLCBzbGlkZVdpZHRoLCBkdXJhdGlvbilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGluZGV4KSB7XG4gICAgICAgICAgICAgIHRoaXMubW92ZShpbmRleCAtIDEsIC1zbGlkZVdpZHRoLCBkdXJhdGlvbilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubW92ZShpbmRleCwgMCwgZHVyYXRpb24pXG4gICAgICAgICAgICBpZiAoaW5kZXggPCB0aGlzLm51bSAtIDEpIHtcbiAgICAgICAgICAgICAgdGhpcy5tb3ZlKGluZGV4ICsgMSwgc2xpZGVXaWR0aCwgZHVyYXRpb24pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNWYWxpZENsb3NlKSB7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTW92ZSBiYWNrIGludG8gcG9zaXRpb25cbiAgICAgICAgICB0aGlzLnRyYW5zbGF0ZVkoaW5kZXgsIDAsIGR1cmF0aW9uKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIG9udG91Y2hjYW5jZWw6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKHRoaXMudG91Y2hTdGFydCkge1xuICAgICAgICB0aGlzLm9udG91Y2hlbmQoZXZlbnQpXG4gICAgICAgIGRlbGV0ZSB0aGlzLnRvdWNoU3RhcnRcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb250cmFuc2l0aW9uZW5kOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBzbGlkZSA9IHRoaXMuc2xpZGVzW3RoaXMuaW5kZXhdXG4gICAgICBpZiAoIWV2ZW50IHx8IHNsaWRlID09PSBldmVudC50YXJnZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJ2YWwpIHtcbiAgICAgICAgICB0aGlzLnBsYXkoKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0VGltZW91dCh0aGlzLm9wdGlvbnMub25zbGlkZWVuZCwgW3RoaXMuaW5kZXgsIHNsaWRlXSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb25jb21wbGV0ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IHx8IGV2ZW50LnNyY0VsZW1lbnRcbiAgICAgIHZhciBwYXJlbnQgPSB0YXJnZXQgJiYgdGFyZ2V0LnBhcmVudE5vZGVcbiAgICAgIHZhciBpbmRleFxuICAgICAgaWYgKCF0YXJnZXQgfHwgIXBhcmVudCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGluZGV4ID0gdGhpcy5nZXROb2RlSW5kZXgocGFyZW50KVxuICAgICAgJChwYXJlbnQpLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5zbGlkZUxvYWRpbmdDbGFzcylcbiAgICAgIGlmIChldmVudC50eXBlID09PSAnZXJyb3InKSB7XG4gICAgICAgICQocGFyZW50KS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuc2xpZGVFcnJvckNsYXNzKVxuICAgICAgICB0aGlzLmVsZW1lbnRzW2luZGV4XSA9IDMgLy8gRmFpbFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbGVtZW50c1tpbmRleF0gPSAyIC8vIERvbmVcbiAgICAgIH1cbiAgICAgIC8vIEZpeCBmb3IgSUU3J3MgbGFjayBvZiBzdXBwb3J0IGZvciBwZXJjZW50YWdlIG1heC1oZWlnaHQ6XG4gICAgICBpZiAodGFyZ2V0LmNsaWVudEhlaWdodCA+IHRoaXMuY29udGFpbmVyWzBdLmNsaWVudEhlaWdodCkge1xuICAgICAgICB0YXJnZXQuc3R5bGUubWF4SGVpZ2h0ID0gdGhpcy5jb250YWluZXJbMF0uY2xpZW50SGVpZ2h0XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pbnRlcnZhbCAmJiB0aGlzLnNsaWRlc1t0aGlzLmluZGV4XSA9PT0gcGFyZW50KSB7XG4gICAgICAgIHRoaXMucGxheSgpXG4gICAgICB9XG4gICAgICB0aGlzLnNldFRpbWVvdXQodGhpcy5vcHRpb25zLm9uc2xpZGVjb21wbGV0ZSwgW2luZGV4LCBwYXJlbnRdKVxuICAgIH0sXG5cbiAgICBvbmxvYWQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdGhpcy5vbmNvbXBsZXRlKGV2ZW50KVxuICAgIH0sXG5cbiAgICBvbmVycm9yOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHRoaXMub25jb21wbGV0ZShldmVudClcbiAgICB9LFxuXG4gICAgb25rZXlkb3duOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHN3aXRjaCAoZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZSkge1xuICAgICAgICBjYXNlIDEzOiAvLyBSZXR1cm5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvZ2dsZUNvbnRyb2xzT25SZXR1cm4pIHtcbiAgICAgICAgICAgIHRoaXMucHJldmVudERlZmF1bHQoZXZlbnQpXG4gICAgICAgICAgICB0aGlzLnRvZ2dsZUNvbnRyb2xzKClcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyNzogLy8gRXNjXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbG9zZU9uRXNjYXBlKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKClcbiAgICAgICAgICAgIC8vIHByZXZlbnQgRXNjIGZyb20gY2xvc2luZyBvdGhlciB0aGluZ3NcbiAgICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzI6IC8vIFNwYWNlXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50b2dnbGVTbGlkZXNob3dPblNwYWNlKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZlbnREZWZhdWx0KGV2ZW50KVxuICAgICAgICAgICAgdGhpcy50b2dnbGVTbGlkZXNob3coKVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM3OiAvLyBMZWZ0XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVLZXlib2FyZE5hdmlnYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucHJldmVudERlZmF1bHQoZXZlbnQpXG4gICAgICAgICAgICB0aGlzLnByZXYoKVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM5OiAvLyBSaWdodFxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlS2V5Ym9hcmROYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZlbnREZWZhdWx0KGV2ZW50KVxuICAgICAgICAgICAgdGhpcy5uZXh0KClcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcbiAgICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQgfHwgZXZlbnQuc3JjRWxlbWVudFxuICAgICAgdmFyIHBhcmVudCA9IHRhcmdldC5wYXJlbnROb2RlXG4gICAgICAvKipcbiAgICAgICAqIENoZWNrcyBpZiB0aGUgdGFyZ2V0IGZyb20gdGhlIGNsb3NlIGhhcyB0aGUgZ2l2ZW4gY2xhc3NcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIENsYXNzIG5hbWVcbiAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIHRhcmdldCBoYXMgdGhlIGNsYXNzIG5hbWVcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gaXNUYXJnZXQoY2xhc3NOYW1lKSB7XG4gICAgICAgIHJldHVybiAkKHRhcmdldCkuaGFzQ2xhc3MoY2xhc3NOYW1lKSB8fCAkKHBhcmVudCkuaGFzQ2xhc3MoY2xhc3NOYW1lKVxuICAgICAgfVxuICAgICAgaWYgKGlzVGFyZ2V0KG9wdGlvbnMudG9nZ2xlQ2xhc3MpKSB7XG4gICAgICAgIC8vIENsaWNrIG9uIFwidG9nZ2xlXCIgY29udHJvbFxuICAgICAgICB0aGlzLnByZXZlbnREZWZhdWx0KGV2ZW50KVxuICAgICAgICB0aGlzLnRvZ2dsZUNvbnRyb2xzKClcbiAgICAgIH0gZWxzZSBpZiAoaXNUYXJnZXQob3B0aW9ucy5wcmV2Q2xhc3MpKSB7XG4gICAgICAgIC8vIENsaWNrIG9uIFwicHJldlwiIGNvbnRyb2xcbiAgICAgICAgdGhpcy5wcmV2ZW50RGVmYXVsdChldmVudClcbiAgICAgICAgdGhpcy5wcmV2KClcbiAgICAgIH0gZWxzZSBpZiAoaXNUYXJnZXQob3B0aW9ucy5uZXh0Q2xhc3MpKSB7XG4gICAgICAgIC8vIENsaWNrIG9uIFwibmV4dFwiIGNvbnRyb2xcbiAgICAgICAgdGhpcy5wcmV2ZW50RGVmYXVsdChldmVudClcbiAgICAgICAgdGhpcy5uZXh0KClcbiAgICAgIH0gZWxzZSBpZiAoaXNUYXJnZXQob3B0aW9ucy5jbG9zZUNsYXNzKSkge1xuICAgICAgICAvLyBDbGljayBvbiBcImNsb3NlXCIgY29udHJvbFxuICAgICAgICB0aGlzLnByZXZlbnREZWZhdWx0KGV2ZW50KVxuICAgICAgICB0aGlzLmNsb3NlKClcbiAgICAgIH0gZWxzZSBpZiAoaXNUYXJnZXQob3B0aW9ucy5wbGF5UGF1c2VDbGFzcykpIHtcbiAgICAgICAgLy8gQ2xpY2sgb24gXCJwbGF5LXBhdXNlXCIgY29udHJvbFxuICAgICAgICB0aGlzLnByZXZlbnREZWZhdWx0KGV2ZW50KVxuICAgICAgICB0aGlzLnRvZ2dsZVNsaWRlc2hvdygpXG4gICAgICB9IGVsc2UgaWYgKHBhcmVudCA9PT0gdGhpcy5zbGlkZXNDb250YWluZXJbMF0pIHtcbiAgICAgICAgLy8gQ2xpY2sgb24gc2xpZGUgYmFja2dyb3VuZFxuICAgICAgICBpZiAob3B0aW9ucy5jbG9zZU9uU2xpZGVDbGljaykge1xuICAgICAgICAgIHRoaXMucHJldmVudERlZmF1bHQoZXZlbnQpXG4gICAgICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy50b2dnbGVDb250cm9sc09uU2xpZGVDbGljaykge1xuICAgICAgICAgIHRoaXMucHJldmVudERlZmF1bHQoZXZlbnQpXG4gICAgICAgICAgdGhpcy50b2dnbGVDb250cm9scygpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHBhcmVudC5wYXJlbnROb2RlICYmXG4gICAgICAgIHBhcmVudC5wYXJlbnROb2RlID09PSB0aGlzLnNsaWRlc0NvbnRhaW5lclswXVxuICAgICAgKSB7XG4gICAgICAgIC8vIENsaWNrIG9uIGRpc3BsYXllZCBlbGVtZW50XG4gICAgICAgIGlmIChvcHRpb25zLnRvZ2dsZUNvbnRyb2xzT25TbGlkZUNsaWNrKSB7XG4gICAgICAgICAgdGhpcy5wcmV2ZW50RGVmYXVsdChldmVudClcbiAgICAgICAgICB0aGlzLnRvZ2dsZUNvbnRyb2xzKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBvbmNsaWNrOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5vcHRpb25zLmVtdWxhdGVUb3VjaEV2ZW50cyAmJlxuICAgICAgICB0aGlzLnRvdWNoRGVsdGEgJiZcbiAgICAgICAgKE1hdGguYWJzKHRoaXMudG91Y2hEZWx0YS54KSA+IDIwIHx8IE1hdGguYWJzKHRoaXMudG91Y2hEZWx0YS55KSA+IDIwKVxuICAgICAgKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRvdWNoRGVsdGFcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVDbGljayhldmVudClcbiAgICB9LFxuXG4gICAgdXBkYXRlRWRnZUNsYXNzZXM6IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgaWYgKCFpbmRleCkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRDbGFzcyh0aGlzLm9wdGlvbnMubGVmdEVkZ2VDbGFzcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5sZWZ0RWRnZUNsYXNzKVxuICAgICAgfVxuICAgICAgaWYgKGluZGV4ID09PSB0aGlzLm51bSAtIDEpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnJpZ2h0RWRnZUNsYXNzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLnJpZ2h0RWRnZUNsYXNzKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBoYW5kbGVTbGlkZTogZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5jb250aW51b3VzKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRWRnZUNsYXNzZXMoaW5kZXgpXG4gICAgICB9XG4gICAgICB0aGlzLmxvYWRFbGVtZW50cyhpbmRleClcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudW5sb2FkRWxlbWVudHMpIHtcbiAgICAgICAgdGhpcy51bmxvYWRFbGVtZW50cyhpbmRleClcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0VGl0bGUoaW5kZXgpXG4gICAgfSxcblxuICAgIG9uc2xpZGU6IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgdGhpcy5pbmRleCA9IGluZGV4XG4gICAgICB0aGlzLmhhbmRsZVNsaWRlKGluZGV4KVxuICAgICAgdGhpcy5zZXRUaW1lb3V0KHRoaXMub3B0aW9ucy5vbnNsaWRlLCBbaW5kZXgsIHRoaXMuc2xpZGVzW2luZGV4XV0pXG4gICAgfSxcblxuICAgIHNldFRpdGxlOiBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIHZhciBmaXJzdENoaWxkID0gdGhpcy5zbGlkZXNbaW5kZXhdLmZpcnN0Q2hpbGRcbiAgICAgIHZhciB0ZXh0ID0gZmlyc3RDaGlsZC50aXRsZSB8fCBmaXJzdENoaWxkLmFsdFxuICAgICAgdmFyIHRpdGxlRWxlbWVudCA9IHRoaXMudGl0bGVFbGVtZW50XG4gICAgICBpZiAodGl0bGVFbGVtZW50Lmxlbmd0aCkge1xuICAgICAgICB0aGlzLnRpdGxlRWxlbWVudC5lbXB0eSgpXG4gICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgdGl0bGVFbGVtZW50WzBdLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNldFRpbWVvdXQ6IGZ1bmN0aW9uIChmdW5jLCBhcmdzLCB3YWl0KSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGZ1bmMgJiZcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZ1bmMuYXBwbHkodGhhdCwgYXJncyB8fCBbXSlcbiAgICAgICAgfSwgd2FpdCB8fCAwKVxuICAgICAgKVxuICAgIH0sXG5cbiAgICBpbWFnZUZhY3Rvcnk6IGZ1bmN0aW9uIChvYmosIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAgIHZhciBpbWcgPSB0aGlzLmltYWdlUHJvdG90eXBlLmNsb25lTm9kZShmYWxzZSlcbiAgICAgIHZhciB1cmwgPSBvYmpcbiAgICAgIHZhciBiYWNrZ3JvdW5kU2l6ZSA9IHRoaXMub3B0aW9ucy5zdHJldGNoSW1hZ2VzXG4gICAgICB2YXIgY2FsbGVkXG4gICAgICB2YXIgZWxlbWVudFxuICAgICAgdmFyIHRpdGxlXG4gICAgICB2YXIgYWx0VGV4dFxuICAgICAgLyoqXG4gICAgICAgKiBXcmFwcyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIHRoZSBsb2FkL2Vycm9yIGV2ZW50XG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtldmVudH0gZXZlbnQgbG9hZC9lcnJvciBldmVudFxuICAgICAgICogQHJldHVybnMge251bWJlcn0gdGltZW91dCBJRFxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBjYWxsYmFja1dyYXBwZXIoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgICBldmVudCA9IHtcbiAgICAgICAgICAgIHR5cGU6IGV2ZW50LnR5cGUsXG4gICAgICAgICAgICB0YXJnZXQ6IGVsZW1lbnRcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIC8vIEZpeCBmb3IgSUU3IGZpcmluZyB0aGUgbG9hZCBldmVudCBmb3JcbiAgICAgICAgICAgIC8vIGNhY2hlZCBpbWFnZXMgYmVmb3JlIHRoZSBlbGVtZW50IGNvdWxkXG4gICAgICAgICAgICAvLyBiZSBhZGRlZCB0byB0aGUgRE9NOlxuICAgICAgICAgICAgcmV0dXJuIHRoYXQuc2V0VGltZW91dChjYWxsYmFja1dyYXBwZXIsIFtldmVudF0pXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxlZCA9IHRydWVcbiAgICAgICAgICAkKGltZykub2ZmKCdsb2FkIGVycm9yJywgY2FsbGJhY2tXcmFwcGVyKVxuICAgICAgICAgIGlmIChiYWNrZ3JvdW5kU2l6ZSkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdsb2FkJykge1xuICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLmJhY2tncm91bmQgPSAndXJsKFwiJyArIHVybCArICdcIikgY2VudGVyIG5vLXJlcGVhdCdcbiAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9IGJhY2tncm91bmRTaXplXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrKGV2ZW50KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdXJsID0gdGhpcy5nZXRJdGVtUHJvcGVydHkob2JqLCB0aGlzLm9wdGlvbnMudXJsUHJvcGVydHkpXG4gICAgICAgIHRpdGxlID0gdGhpcy5nZXRJdGVtUHJvcGVydHkob2JqLCB0aGlzLm9wdGlvbnMudGl0bGVQcm9wZXJ0eSlcbiAgICAgICAgYWx0VGV4dCA9XG4gICAgICAgICAgdGhpcy5nZXRJdGVtUHJvcGVydHkob2JqLCB0aGlzLm9wdGlvbnMuYWx0VGV4dFByb3BlcnR5KSB8fCB0aXRsZVxuICAgICAgfVxuICAgICAgaWYgKGJhY2tncm91bmRTaXplID09PSB0cnVlKSB7XG4gICAgICAgIGJhY2tncm91bmRTaXplID0gJ2NvbnRhaW4nXG4gICAgICB9XG4gICAgICBiYWNrZ3JvdW5kU2l6ZSA9XG4gICAgICAgIHRoaXMuc3VwcG9ydC5iYWNrZ3JvdW5kU2l6ZSAmJlxuICAgICAgICB0aGlzLnN1cHBvcnQuYmFja2dyb3VuZFNpemVbYmFja2dyb3VuZFNpemVdICYmXG4gICAgICAgIGJhY2tncm91bmRTaXplXG4gICAgICBpZiAoYmFja2dyb3VuZFNpemUpIHtcbiAgICAgICAgZWxlbWVudCA9IHRoaXMuZWxlbWVudFByb3RvdHlwZS5jbG9uZU5vZGUoZmFsc2UpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50ID0gaW1nXG4gICAgICAgIGltZy5kcmFnZ2FibGUgPSBmYWxzZVxuICAgICAgfVxuICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgIGVsZW1lbnQudGl0bGUgPSB0aXRsZVxuICAgICAgfVxuICAgICAgaWYgKGFsdFRleHQpIHtcbiAgICAgICAgZWxlbWVudC5hbHQgPSBhbHRUZXh0XG4gICAgICB9XG4gICAgICAkKGltZykub24oJ2xvYWQgZXJyb3InLCBjYWxsYmFja1dyYXBwZXIpXG4gICAgICBpbWcuc3JjID0gdXJsXG4gICAgICByZXR1cm4gZWxlbWVudFxuICAgIH0sXG5cbiAgICBjcmVhdGVFbGVtZW50OiBmdW5jdGlvbiAob2JqLCBjYWxsYmFjaykge1xuICAgICAgdmFyIHR5cGUgPSBvYmogJiYgdGhpcy5nZXRJdGVtUHJvcGVydHkob2JqLCB0aGlzLm9wdGlvbnMudHlwZVByb3BlcnR5KVxuICAgICAgdmFyIGZhY3RvcnkgPVxuICAgICAgICAodHlwZSAmJiB0aGlzW3R5cGUuc3BsaXQoJy8nKVswXSArICdGYWN0b3J5J10pIHx8IHRoaXMuaW1hZ2VGYWN0b3J5XG4gICAgICB2YXIgZWxlbWVudCA9IG9iaiAmJiBmYWN0b3J5LmNhbGwodGhpcywgb2JqLCBjYWxsYmFjaylcbiAgICAgIHZhciBzcmNzZXQgPSB0aGlzLmdldEl0ZW1Qcm9wZXJ0eShvYmosIHRoaXMub3B0aW9ucy5zcmNzZXRQcm9wZXJ0eSlcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50ID0gdGhpcy5lbGVtZW50UHJvdG90eXBlLmNsb25lTm9kZShmYWxzZSlcbiAgICAgICAgdGhpcy5zZXRUaW1lb3V0KGNhbGxiYWNrLCBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICAgIHRhcmdldDogZWxlbWVudFxuICAgICAgICAgIH1cbiAgICAgICAgXSlcbiAgICAgIH1cbiAgICAgIGlmIChzcmNzZXQpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3NyY3NldCcsIHNyY3NldClcbiAgICAgIH1cbiAgICAgICQoZWxlbWVudCkuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnNsaWRlQ29udGVudENsYXNzKVxuICAgICAgcmV0dXJuIGVsZW1lbnRcbiAgICB9LFxuXG4gICAgbG9hZEVsZW1lbnQ6IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgaWYgKCF0aGlzLmVsZW1lbnRzW2luZGV4XSkge1xuICAgICAgICBpZiAodGhpcy5zbGlkZXNbaW5kZXhdLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICB0aGlzLmVsZW1lbnRzW2luZGV4XSA9ICQodGhpcy5zbGlkZXNbaW5kZXhdKS5oYXNDbGFzcyhcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zbGlkZUVycm9yQ2xhc3NcbiAgICAgICAgICApXG4gICAgICAgICAgICA/IDNcbiAgICAgICAgICAgIDogMlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZWxlbWVudHNbaW5kZXhdID0gMSAvLyBMb2FkaW5nXG4gICAgICAgICAgJCh0aGlzLnNsaWRlc1tpbmRleF0pLmFkZENsYXNzKHRoaXMub3B0aW9ucy5zbGlkZUxvYWRpbmdDbGFzcylcbiAgICAgICAgICB0aGlzLnNsaWRlc1tpbmRleF0uYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUVsZW1lbnQodGhpcy5saXN0W2luZGV4XSwgdGhpcy5wcm94eUxpc3RlbmVyKVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBsb2FkRWxlbWVudHM6IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgdmFyIGxpbWl0ID0gTWF0aC5taW4odGhpcy5udW0sIHRoaXMub3B0aW9ucy5wcmVsb2FkUmFuZ2UgKiAyICsgMSlcbiAgICAgIHZhciBqID0gaW5kZXhcbiAgICAgIHZhciBpXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGltaXQ7IGkgKz0gMSkge1xuICAgICAgICAvLyBGaXJzdCBsb2FkIHRoZSBjdXJyZW50IHNsaWRlIGVsZW1lbnQgKDApLFxuICAgICAgICAvLyB0aGVuIHRoZSBuZXh0IG9uZSAoKzEpLFxuICAgICAgICAvLyB0aGVuIHRoZSBwcmV2aW91cyBvbmUgKC0yKSxcbiAgICAgICAgLy8gdGhlbiB0aGUgbmV4dCBhZnRlciBuZXh0ICgrMiksIGV0Yy46XG4gICAgICAgIGogKz0gaSAqIChpICUgMiA9PT0gMCA/IC0xIDogMSlcbiAgICAgICAgLy8gQ29ubmVjdCB0aGUgZW5kcyBvZiB0aGUgbGlzdCB0byBsb2FkIHNsaWRlIGVsZW1lbnRzIGZvclxuICAgICAgICAvLyBjb250aW51b3VzIG5hdmlnYXRpb246XG4gICAgICAgIGogPSB0aGlzLmNpcmNsZShqKVxuICAgICAgICB0aGlzLmxvYWRFbGVtZW50KGopXG4gICAgICB9XG4gICAgfSxcblxuICAgIHVubG9hZEVsZW1lbnRzOiBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIHZhciBpLCBkaWZmXG4gICAgICBmb3IgKGkgaW4gdGhpcy5lbGVtZW50cykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuZWxlbWVudHMsIGkpKSB7XG4gICAgICAgICAgZGlmZiA9IE1hdGguYWJzKGluZGV4IC0gaSlcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBkaWZmID4gdGhpcy5vcHRpb25zLnByZWxvYWRSYW5nZSAmJlxuICAgICAgICAgICAgZGlmZiArIHRoaXMub3B0aW9ucy5wcmVsb2FkUmFuZ2UgPCB0aGlzLm51bVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy51bmxvYWRTbGlkZShpKVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZWxlbWVudHNbaV1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWRkU2xpZGU6IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgdmFyIHNsaWRlID0gdGhpcy5zbGlkZVByb3RvdHlwZS5jbG9uZU5vZGUoZmFsc2UpXG4gICAgICBzbGlkZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaW5kZXgnLCBpbmRleClcbiAgICAgIHRoaXMuc2xpZGVzQ29udGFpbmVyWzBdLmFwcGVuZENoaWxkKHNsaWRlKVxuICAgICAgdGhpcy5zbGlkZXMucHVzaChzbGlkZSlcbiAgICB9LFxuXG4gICAgcG9zaXRpb25TbGlkZTogZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICB2YXIgc2xpZGUgPSB0aGlzLnNsaWRlc1tpbmRleF1cbiAgICAgIHNsaWRlLnN0eWxlLndpZHRoID0gdGhpcy5zbGlkZVdpZHRoICsgJ3B4J1xuICAgICAgaWYgKHRoaXMuc3VwcG9ydC50cmFuc2Zvcm0pIHtcbiAgICAgICAgc2xpZGUuc3R5bGUubGVmdCA9IGluZGV4ICogLXRoaXMuc2xpZGVXaWR0aCArICdweCdcbiAgICAgICAgdGhpcy5tb3ZlKFxuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIHRoaXMuaW5kZXggPiBpbmRleFxuICAgICAgICAgICAgPyAtdGhpcy5zbGlkZVdpZHRoXG4gICAgICAgICAgICA6IHRoaXMuaW5kZXggPCBpbmRleFxuICAgICAgICAgICAgPyB0aGlzLnNsaWRlV2lkdGhcbiAgICAgICAgICAgIDogMCxcbiAgICAgICAgICAwXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaW5pdFNsaWRlczogZnVuY3Rpb24gKHJlbG9hZCkge1xuICAgICAgdmFyIGNsZWFyU2xpZGVzLCBpXG4gICAgICBpZiAoIXJlbG9hZCkge1xuICAgICAgICB0aGlzLnBvc2l0aW9ucyA9IFtdXG4gICAgICAgIHRoaXMucG9zaXRpb25zLmxlbmd0aCA9IHRoaXMubnVtXG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSB7fVxuICAgICAgICB0aGlzLmltYWdlUHJvdG90eXBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJylcbiAgICAgICAgdGhpcy5lbGVtZW50UHJvdG90eXBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgICAgdGhpcy5zbGlkZVByb3RvdHlwZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICAgICQodGhpcy5zbGlkZVByb3RvdHlwZSkuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpXG4gICAgICAgIHRoaXMuc2xpZGVzID0gdGhpcy5zbGlkZXNDb250YWluZXJbMF0uY2hpbGRyZW5cbiAgICAgICAgY2xlYXJTbGlkZXMgPVxuICAgICAgICAgIHRoaXMub3B0aW9ucy5jbGVhclNsaWRlcyB8fCB0aGlzLnNsaWRlcy5sZW5ndGggIT09IHRoaXMubnVtXG4gICAgICB9XG4gICAgICB0aGlzLnNsaWRlV2lkdGggPSB0aGlzLmNvbnRhaW5lclswXS5jbGllbnRXaWR0aFxuICAgICAgdGhpcy5zbGlkZUhlaWdodCA9IHRoaXMuY29udGFpbmVyWzBdLmNsaWVudEhlaWdodFxuICAgICAgdGhpcy5zbGlkZXNDb250YWluZXJbMF0uc3R5bGUud2lkdGggPSB0aGlzLm51bSAqIHRoaXMuc2xpZGVXaWR0aCArICdweCdcbiAgICAgIGlmIChjbGVhclNsaWRlcykge1xuICAgICAgICB0aGlzLnJlc2V0U2xpZGVzKClcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLm51bTsgaSArPSAxKSB7XG4gICAgICAgIGlmIChjbGVhclNsaWRlcykge1xuICAgICAgICAgIHRoaXMuYWRkU2xpZGUoaSlcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvc2l0aW9uU2xpZGUoaSlcbiAgICAgIH1cbiAgICAgIC8vIFJlcG9zaXRpb24gdGhlIHNsaWRlcyBiZWZvcmUgYW5kIGFmdGVyIHRoZSBnaXZlbiBpbmRleDpcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29udGludW91cyAmJiB0aGlzLnN1cHBvcnQudHJhbnNmb3JtKSB7XG4gICAgICAgIHRoaXMubW92ZSh0aGlzLmNpcmNsZSh0aGlzLmluZGV4IC0gMSksIC10aGlzLnNsaWRlV2lkdGgsIDApXG4gICAgICAgIHRoaXMubW92ZSh0aGlzLmNpcmNsZSh0aGlzLmluZGV4ICsgMSksIHRoaXMuc2xpZGVXaWR0aCwgMClcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5zdXBwb3J0LnRyYW5zZm9ybSkge1xuICAgICAgICB0aGlzLnNsaWRlc0NvbnRhaW5lclswXS5zdHlsZS5sZWZ0ID1cbiAgICAgICAgICB0aGlzLmluZGV4ICogLXRoaXMuc2xpZGVXaWR0aCArICdweCdcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdW5sb2FkU2xpZGU6IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgdmFyIHNsaWRlLCBmaXJzdENoaWxkXG4gICAgICBzbGlkZSA9IHRoaXMuc2xpZGVzW2luZGV4XVxuICAgICAgZmlyc3RDaGlsZCA9IHNsaWRlLmZpcnN0Q2hpbGRcbiAgICAgIGlmIChmaXJzdENoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIHNsaWRlLnJlbW92ZUNoaWxkKGZpcnN0Q2hpbGQpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHVubG9hZEFsbFNsaWRlczogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGksIGxlblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5zbGlkZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy51bmxvYWRTbGlkZShpKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB0b2dnbGVDb250cm9sczogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRyb2xzQ2xhc3MgPSB0aGlzLm9wdGlvbnMuY29udHJvbHNDbGFzc1xuICAgICAgaWYgKHRoaXMuY29udGFpbmVyLmhhc0NsYXNzKGNvbnRyb2xzQ2xhc3MpKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUNsYXNzKGNvbnRyb2xzQ2xhc3MpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRDbGFzcyhjb250cm9sc0NsYXNzKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB0b2dnbGVTbGlkZXNob3c6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5pbnRlcnZhbCkge1xuICAgICAgICB0aGlzLnBsYXkoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpXG4gICAgICB9XG4gICAgfSxcblxuICAgIGdldE5vZGVJbmRleDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBwYXJzZUludChlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1pbmRleCcpLCAxMClcbiAgICB9LFxuXG4gICAgZ2V0TmVzdGVkUHJvcGVydHk6IGZ1bmN0aW9uIChvYmosIHByb3BlcnR5KSB7XG4gICAgICBwcm9wZXJ0eS5yZXBsYWNlKFxuICAgICAgICAvLyBNYXRjaGVzIG5hdGl2ZSBKYXZhU2NyaXB0IG5vdGF0aW9uIGluIGEgU3RyaW5nLFxuICAgICAgICAvLyBlLmcuICdbXCJkb3VibGVRdW90ZVByb3BcIl0uZG90UHJvcFsyXSdcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG4gICAgICAgIC9cXFsoPzonKFteJ10rKSd8XCIoW15cIl0rKVwifChcXGQrKSlcXF18KD86KD86XnxcXC4pKFteXFwuXFxbXSspKS9nLFxuICAgICAgICBmdW5jdGlvbiAoc3RyLCBzaW5nbGVRdW90ZVByb3AsIGRvdWJsZVF1b3RlUHJvcCwgYXJyYXlJbmRleCwgZG90UHJvcCkge1xuICAgICAgICAgIHZhciBwcm9wID1cbiAgICAgICAgICAgIGRvdFByb3AgfHxcbiAgICAgICAgICAgIHNpbmdsZVF1b3RlUHJvcCB8fFxuICAgICAgICAgICAgZG91YmxlUXVvdGVQcm9wIHx8XG4gICAgICAgICAgICAoYXJyYXlJbmRleCAmJiBwYXJzZUludChhcnJheUluZGV4LCAxMCkpXG4gICAgICAgICAgaWYgKHN0ciAmJiBvYmopIHtcbiAgICAgICAgICAgIG9iaiA9IG9ialtwcm9wXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKVxuICAgICAgcmV0dXJuIG9ialxuICAgIH0sXG5cbiAgICBnZXREYXRhUHJvcGVydHk6IGZ1bmN0aW9uIChvYmosIHByb3BlcnR5KSB7XG4gICAgICB2YXIga2V5XG4gICAgICB2YXIgcHJvcFxuICAgICAgaWYgKG9iai5kYXRhc2V0KSB7XG4gICAgICAgIGtleSA9IHByb3BlcnR5LnJlcGxhY2UoLy0oW2Etel0pL2csIGZ1bmN0aW9uIChfLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGIudG9VcHBlckNhc2UoKVxuICAgICAgICB9KVxuICAgICAgICBwcm9wID0gb2JqLmRhdGFzZXRba2V5XVxuICAgICAgfSBlbHNlIGlmIChvYmouZ2V0QXR0cmlidXRlKSB7XG4gICAgICAgIHByb3AgPSBvYmouZ2V0QXR0cmlidXRlKFxuICAgICAgICAgICdkYXRhLScgKyBwcm9wZXJ0eS5yZXBsYWNlKC8oW0EtWl0pL2csICctJDEnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG4gICAgICAgIGlmIChcbiAgICAgICAgICAvXih0cnVlfGZhbHNlfG51bGx8LT9cXGQrKFxcLlxcZCspP3xcXHtbXFxzXFxTXSpcXH18XFxbW1xcc1xcU10qXFxdKSQvLnRlc3QocHJvcClcbiAgICAgICAgKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiAkLnBhcnNlSlNPTihwcm9wKVxuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge1xuICAgICAgICAgICAgLy8gaWdub3JlIEpTT04gcGFyc2luZyBlcnJvcnNcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3BcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0SXRlbVByb3BlcnR5OiBmdW5jdGlvbiAob2JqLCBwcm9wZXJ0eSkge1xuICAgICAgdmFyIHByb3AgPSB0aGlzLmdldERhdGFQcm9wZXJ0eShvYmosIHByb3BlcnR5KVxuICAgICAgaWYgKHByb3AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wID0gb2JqW3Byb3BlcnR5XVxuICAgICAgfVxuICAgICAgaWYgKHByb3AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wID0gdGhpcy5nZXROZXN0ZWRQcm9wZXJ0eShvYmosIHByb3BlcnR5KVxuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3BcbiAgICB9LFxuXG4gICAgaW5pdFN0YXJ0SW5kZXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMub3B0aW9ucy5pbmRleFxuICAgICAgdmFyIHVybFByb3BlcnR5ID0gdGhpcy5vcHRpb25zLnVybFByb3BlcnR5XG4gICAgICB2YXIgaVxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGluZGV4IGlzIGdpdmVuIGFzIGEgbGlzdCBvYmplY3Q6XG4gICAgICBpZiAoaW5kZXggJiYgdHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5udW07IGkgKz0gMSkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMubGlzdFtpXSA9PT0gaW5kZXggfHxcbiAgICAgICAgICAgIHRoaXMuZ2V0SXRlbVByb3BlcnR5KHRoaXMubGlzdFtpXSwgdXJsUHJvcGVydHkpID09PVxuICAgICAgICAgICAgICB0aGlzLmdldEl0ZW1Qcm9wZXJ0eShpbmRleCwgdXJsUHJvcGVydHkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpbmRleCA9IGlcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIGluZGV4IGlzIGluIHRoZSBsaXN0IHJhbmdlOlxuICAgICAgdGhpcy5pbmRleCA9IHRoaXMuY2lyY2xlKHBhcnNlSW50KGluZGV4LCAxMCkgfHwgMClcbiAgICB9LFxuXG4gICAgaW5pdEV2ZW50TGlzdGVuZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAgIHZhciBzbGlkZXNDb250YWluZXIgPSB0aGlzLnNsaWRlc0NvbnRhaW5lclxuICAgICAgLyoqXG4gICAgICAgKiBQcm94eSBsaXN0ZW5lclxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7ZXZlbnR9IGV2ZW50IG9yaWdpbmFsIGV2ZW50XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIHByb3h5TGlzdGVuZXIoZXZlbnQpIHtcbiAgICAgICAgdmFyIHR5cGUgPVxuICAgICAgICAgIHRoYXQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoYXQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCA9PT0gZXZlbnQudHlwZVxuICAgICAgICAgICAgPyAndHJhbnNpdGlvbmVuZCdcbiAgICAgICAgICAgIDogZXZlbnQudHlwZVxuICAgICAgICB0aGF0WydvbicgKyB0eXBlXShldmVudClcbiAgICAgIH1cbiAgICAgICQod2luZG93KS5vbigncmVzaXplJywgcHJveHlMaXN0ZW5lcilcbiAgICAgICQod2luZG93KS5vbignaGFzaGNoYW5nZScsIHByb3h5TGlzdGVuZXIpXG4gICAgICAkKGRvY3VtZW50LmJvZHkpLm9uKCdrZXlkb3duJywgcHJveHlMaXN0ZW5lcilcbiAgICAgIHRoaXMuY29udGFpbmVyLm9uKCdjbGljaycsIHByb3h5TGlzdGVuZXIpXG4gICAgICBpZiAodGhpcy5zdXBwb3J0LnRvdWNoKSB7XG4gICAgICAgIHNsaWRlc0NvbnRhaW5lci5vbihcbiAgICAgICAgICAndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnLFxuICAgICAgICAgIHByb3h5TGlzdGVuZXJcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZW11bGF0ZVRvdWNoRXZlbnRzICYmIHRoaXMuc3VwcG9ydC50cmFuc2l0aW9uKSB7XG4gICAgICAgIHNsaWRlc0NvbnRhaW5lci5vbihcbiAgICAgICAgICAnbW91c2Vkb3duIG1vdXNlbW92ZSBtb3VzZXVwIG1vdXNlb3V0JyxcbiAgICAgICAgICBwcm94eUxpc3RlbmVyXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN1cHBvcnQudHJhbnNpdGlvbikge1xuICAgICAgICBzbGlkZXNDb250YWluZXIub24odGhpcy5zdXBwb3J0LnRyYW5zaXRpb24uZW5kLCBwcm94eUxpc3RlbmVyKVxuICAgICAgfVxuICAgICAgdGhpcy5wcm94eUxpc3RlbmVyID0gcHJveHlMaXN0ZW5lclxuICAgIH0sXG5cbiAgICBkZXN0cm95RXZlbnRMaXN0ZW5lcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzbGlkZXNDb250YWluZXIgPSB0aGlzLnNsaWRlc0NvbnRhaW5lclxuICAgICAgdmFyIHByb3h5TGlzdGVuZXIgPSB0aGlzLnByb3h5TGlzdGVuZXJcbiAgICAgICQod2luZG93KS5vZmYoJ3Jlc2l6ZScsIHByb3h5TGlzdGVuZXIpXG4gICAgICAkKGRvY3VtZW50LmJvZHkpLm9mZigna2V5ZG93bicsIHByb3h5TGlzdGVuZXIpXG4gICAgICB0aGlzLmNvbnRhaW5lci5vZmYoJ2NsaWNrJywgcHJveHlMaXN0ZW5lcilcbiAgICAgIGlmICh0aGlzLnN1cHBvcnQudG91Y2gpIHtcbiAgICAgICAgc2xpZGVzQ29udGFpbmVyLm9mZihcbiAgICAgICAgICAndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnLFxuICAgICAgICAgIHByb3h5TGlzdGVuZXJcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZW11bGF0ZVRvdWNoRXZlbnRzICYmIHRoaXMuc3VwcG9ydC50cmFuc2l0aW9uKSB7XG4gICAgICAgIHNsaWRlc0NvbnRhaW5lci5vZmYoXG4gICAgICAgICAgJ21vdXNlZG93biBtb3VzZW1vdmUgbW91c2V1cCBtb3VzZW91dCcsXG4gICAgICAgICAgcHJveHlMaXN0ZW5lclxuICAgICAgICApXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdXBwb3J0LnRyYW5zaXRpb24pIHtcbiAgICAgICAgc2xpZGVzQ29udGFpbmVyLm9mZih0aGlzLnN1cHBvcnQudHJhbnNpdGlvbi5lbmQsIHByb3h5TGlzdGVuZXIpXG4gICAgICB9XG4gICAgfSxcblxuICAgIGhhbmRsZU9wZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub25vcGVuZWQpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9ub3BlbmVkLmNhbGwodGhpcylcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaW5pdFdpZGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgICAvKipcbiAgICAgICAqIE9wZW4gaGFuZGxlclxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7ZXZlbnR9IGV2ZW50IEdhbGxlcnkgb3BlbiBldmVudFxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBvcGVuSGFuZGxlcihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGF0LmNvbnRhaW5lclswXSkge1xuICAgICAgICAgIHRoYXQuY29udGFpbmVyLm9mZih0aGF0LnN1cHBvcnQudHJhbnNpdGlvbi5lbmQsIG9wZW5IYW5kbGVyKVxuICAgICAgICAgIHRoYXQuaGFuZGxlT3BlbigpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuY29udGFpbmVyID0gJCh0aGlzLm9wdGlvbnMuY29udGFpbmVyKVxuICAgICAgaWYgKCF0aGlzLmNvbnRhaW5lci5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5jb25zb2xlLmxvZyhcbiAgICAgICAgICAnYmx1ZWltcCBHYWxsZXJ5OiBXaWRnZXQgY29udGFpbmVyIG5vdCBmb3VuZC4nLFxuICAgICAgICAgIHRoaXMub3B0aW9ucy5jb250YWluZXJcbiAgICAgICAgKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHRoaXMuc2xpZGVzQ29udGFpbmVyID0gdGhpcy5jb250YWluZXJcbiAgICAgICAgLmZpbmQodGhpcy5vcHRpb25zLnNsaWRlc0NvbnRhaW5lcilcbiAgICAgICAgLmZpcnN0KClcbiAgICAgIGlmICghdGhpcy5zbGlkZXNDb250YWluZXIubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuY29uc29sZS5sb2coXG4gICAgICAgICAgJ2JsdWVpbXAgR2FsbGVyeTogU2xpZGVzIGNvbnRhaW5lciBub3QgZm91bmQuJyxcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuc2xpZGVzQ29udGFpbmVyXG4gICAgICAgIClcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICB0aGlzLnRpdGxlRWxlbWVudCA9IHRoaXMuY29udGFpbmVyLmZpbmQodGhpcy5vcHRpb25zLnRpdGxlRWxlbWVudCkuZmlyc3QoKVxuICAgICAgaWYgKHRoaXMubnVtID09PSAxKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENsYXNzKHRoaXMub3B0aW9ucy5zaW5nbGVDbGFzcylcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub25vcGVuKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vbm9wZW4uY2FsbCh0aGlzKVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoaXMub3B0aW9ucy5kaXNwbGF5VHJhbnNpdGlvbikge1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5vbih0aGlzLnN1cHBvcnQudHJhbnNpdGlvbi5lbmQsIG9wZW5IYW5kbGVyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVPcGVuKClcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGlkZVBhZ2VTY3JvbGxiYXJzKSB7XG4gICAgICAgIC8vIEhpZGUgdGhlIHBhZ2Ugc2Nyb2xsYmFyczpcbiAgICAgICAgdGhpcy5ib2R5T3ZlcmZsb3dTdHlsZSA9IGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3dcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nXG4gICAgICB9XG4gICAgICB0aGlzLmNvbnRhaW5lclswXS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgICAgdGhpcy5pbml0U2xpZGVzKClcbiAgICAgIHRoaXMuY29udGFpbmVyLmFkZENsYXNzKHRoaXMub3B0aW9ucy5kaXNwbGF5Q2xhc3MpXG4gICAgfSxcblxuICAgIGluaXRPcHRpb25zOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGUgcHJvdG90eXBlIG9wdGlvbnM6XG4gICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zKVxuICAgICAgLy8gQ2hlY2sgaWYgY2Fyb3VzZWwgbW9kZSBpcyBlbmFibGVkOlxuICAgICAgaWYgKFxuICAgICAgICAob3B0aW9ucyAmJiBvcHRpb25zLmNhcm91c2VsKSB8fFxuICAgICAgICAodGhpcy5vcHRpb25zLmNhcm91c2VsICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmNhcm91c2VsICE9PSBmYWxzZSkpXG4gICAgICApIHtcbiAgICAgICAgJC5leHRlbmQodGhpcy5vcHRpb25zLCB0aGlzLmNhcm91c2VsT3B0aW9ucylcbiAgICAgIH1cbiAgICAgIC8vIE92ZXJyaWRlIGFueSBnaXZlbiBvcHRpb25zOlxuICAgICAgJC5leHRlbmQodGhpcy5vcHRpb25zLCBvcHRpb25zKVxuICAgICAgaWYgKHRoaXMubnVtIDwgMykge1xuICAgICAgICAvLyAxIG9yIDIgc2xpZGVzIGNhbm5vdCBiZSBkaXNwbGF5ZWQgY29udGludW91cyxcbiAgICAgICAgLy8gcmVtZW1iZXIgdGhlIG9yaWdpbmFsIG9wdGlvbiBieSBzZXR0aW5nIHRvIG51bGwgaW5zdGVhZCBvZiBmYWxzZTpcbiAgICAgICAgdGhpcy5vcHRpb25zLmNvbnRpbnVvdXMgPSB0aGlzLm9wdGlvbnMuY29udGludW91cyA/IG51bGwgOiBmYWxzZVxuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnN1cHBvcnQudHJhbnNpdGlvbikge1xuICAgICAgICB0aGlzLm9wdGlvbnMuZW11bGF0ZVRvdWNoRXZlbnRzID0gZmFsc2VcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXZlbnQpIHtcbiAgICAgICAgdGhpcy5wcmV2ZW50RGVmYXVsdCh0aGlzLm9wdGlvbnMuZXZlbnQpXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBHYWxsZXJ5XG59KVxuIiwiLypcbiAqIGJsdWVpbXAgaGVscGVyIEpTXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9HYWxsZXJ5XG4gKlxuICogQ29weXJpZ2h0IDIwMTMsIFNlYmFzdGlhbiBUc2NoYW5cbiAqIGh0dHBzOi8vYmx1ZWltcC5uZXRcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICovXG5cbi8qIGdsb2JhbCBkZWZpbmUgKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cblxuOyhmdW5jdGlvbiAoKSB7XG4gICd1c2Ugc3RyaWN0J1xuXG4gIC8qKlxuICAgKiBPYmplY3QuYXNzaWduIHBvbHlmaWxsXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvYmoxIEZpcnN0IG9iamVjdFxuICAgKiBAcGFyYW0ge29iamVjdH0gb2JqMiBTZWNvbmQgb2JqZWN0XG4gICAqIEByZXR1cm5zIHtvYmplY3R9IE1lcmdlZCBvYmplY3RcbiAgICovXG4gIGZ1bmN0aW9uIGV4dGVuZChvYmoxLCBvYmoyKSB7XG4gICAgdmFyIHByb3BcbiAgICBmb3IgKHByb3AgaW4gb2JqMikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmoyLCBwcm9wKSkge1xuICAgICAgICBvYmoxW3Byb3BdID0gb2JqMltwcm9wXVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqMVxuICB9XG4gIC8qKlxuICAgKiBIZWxwZXIgY29uc3RydWN0b3JcbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7Kn0gcXVlcnkgalF1ZXJ5IHR5cGUgcXVlcnkgYXJndW1lbnRcbiAgICovXG4gIGZ1bmN0aW9uIEhlbHBlcihxdWVyeSkge1xuICAgIGlmICghdGhpcyB8fCB0aGlzLmZpbmQgIT09IEhlbHBlci5wcm90b3R5cGUuZmluZCkge1xuICAgICAgLy8gQ2FsbGVkIGFzIGZ1bmN0aW9uIGluc3RlYWQgb2YgYXMgY29uc3RydWN0b3IsXG4gICAgICAvLyBzbyB3ZSBzaW1wbHkgcmV0dXJuIGEgbmV3IGluc3RhbmNlOlxuICAgICAgcmV0dXJuIG5ldyBIZWxwZXIocXVlcnkpXG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gMFxuICAgIGlmIChxdWVyeSkge1xuICAgICAgaWYgKHR5cGVvZiBxdWVyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcXVlcnkgPSB0aGlzLmZpbmQocXVlcnkpXG4gICAgICB9XG4gICAgICBpZiAocXVlcnkubm9kZVR5cGUgfHwgcXVlcnkgPT09IHF1ZXJ5LndpbmRvdykge1xuICAgICAgICAvLyBTaW5nbGUgSFRNTCBlbGVtZW50XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMVxuICAgICAgICB0aGlzWzBdID0gcXVlcnlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEhUTUwgZWxlbWVudCBjb2xsZWN0aW9uXG4gICAgICAgIHZhciBpID0gcXVlcnkubGVuZ3RoXG4gICAgICAgIHRoaXMubGVuZ3RoID0gaVxuICAgICAgICB3aGlsZSAoaSkge1xuICAgICAgICAgIGkgLT0gMVxuICAgICAgICAgIHRoaXNbaV0gPSBxdWVyeVtpXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgSGVscGVyLmV4dGVuZCA9IGV4dGVuZFxuXG4gIEhlbHBlci5jb250YWlucyA9IGZ1bmN0aW9uIChjb250YWluZXIsIGVsZW1lbnQpIHtcbiAgICBkbyB7XG4gICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlXG4gICAgICBpZiAoZWxlbWVudCA9PT0gY29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfSB3aGlsZSAoZWxlbWVudClcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIEhlbHBlci5wYXJzZUpTT04gPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5KU09OICYmIEpTT04ucGFyc2Uoc3RyaW5nKVxuICB9XG5cbiAgZXh0ZW5kKEhlbHBlci5wcm90b3R5cGUsIHtcbiAgICBmaW5kOiBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgIHZhciBjb250YWluZXIgPSB0aGlzWzBdIHx8IGRvY3VtZW50XG4gICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwpIHtcbiAgICAgICAgICBxdWVyeSA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KVxuICAgICAgICB9IGVsc2UgaWYgKHF1ZXJ5LmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgcXVlcnkgPSBjb250YWluZXIuZ2V0RWxlbWVudEJ5SWQocXVlcnkuc2xpY2UoMSkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcXVlcnkgPSBjb250YWluZXIuZ2V0RWxlbWVudHNCeVRhZ05hbWUocXVlcnkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgSGVscGVyKHF1ZXJ5KVxuICAgIH0sXG5cbiAgICBoYXNDbGFzczogZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgICAgaWYgKCF0aGlzWzBdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoJyhefFxcXFxzKyknICsgY2xhc3NOYW1lICsgJyhcXFxccyt8JCknKS50ZXN0KFxuICAgICAgICB0aGlzWzBdLmNsYXNzTmFtZVxuICAgICAgKVxuICAgIH0sXG5cbiAgICBhZGRDbGFzczogZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgICAgdmFyIGkgPSB0aGlzLmxlbmd0aFxuICAgICAgdmFyIGVsZW1lbnRcbiAgICAgIHdoaWxlIChpKSB7XG4gICAgICAgIGkgLT0gMVxuICAgICAgICBlbGVtZW50ID0gdGhpc1tpXVxuICAgICAgICBpZiAoIWVsZW1lbnQuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBjbGFzc05hbWVcbiAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhhc0NsYXNzKGNsYXNzTmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lICs9ICcgJyArIGNsYXNzTmFtZVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuXG4gICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKCcoXnxcXFxccyspJyArIGNsYXNzTmFtZSArICcoXFxcXHMrfCQpJylcbiAgICAgIHZhciBpID0gdGhpcy5sZW5ndGhcbiAgICAgIHZhciBlbGVtZW50XG4gICAgICB3aGlsZSAoaSkge1xuICAgICAgICBpIC09IDFcbiAgICAgICAgZWxlbWVudCA9IHRoaXNbaV1cbiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZS5yZXBsYWNlKHJlZ2V4cCwgJyAnKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuXG4gICAgb246IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgIHZhciBldmVudE5hbWVzID0gZXZlbnROYW1lLnNwbGl0KC9cXHMrLylcbiAgICAgIHZhciBpXG4gICAgICB2YXIgZWxlbWVudFxuICAgICAgd2hpbGUgKGV2ZW50TmFtZXMubGVuZ3RoKSB7XG4gICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZXMuc2hpZnQoKVxuICAgICAgICBpID0gdGhpcy5sZW5ndGhcbiAgICAgICAgd2hpbGUgKGkpIHtcbiAgICAgICAgICBpIC09IDFcbiAgICAgICAgICBlbGVtZW50ID0gdGhpc1tpXVxuICAgICAgICAgIGlmIChlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIGZhbHNlKVxuICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5hdHRhY2hFdmVudCkge1xuICAgICAgICAgICAgZWxlbWVudC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnROYW1lLCBoYW5kbGVyKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuXG4gICAgb2ZmOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICB2YXIgZXZlbnROYW1lcyA9IGV2ZW50TmFtZS5zcGxpdCgvXFxzKy8pXG4gICAgICB2YXIgaVxuICAgICAgdmFyIGVsZW1lbnRcbiAgICAgIHdoaWxlIChldmVudE5hbWVzLmxlbmd0aCkge1xuICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWVzLnNoaWZ0KClcbiAgICAgICAgaSA9IHRoaXMubGVuZ3RoXG4gICAgICAgIHdoaWxlIChpKSB7XG4gICAgICAgICAgaSAtPSAxXG4gICAgICAgICAgZWxlbWVudCA9IHRoaXNbaV1cbiAgICAgICAgICBpZiAoZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBmYWxzZSlcbiAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuZGV0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50TmFtZSwgaGFuZGxlcilcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcblxuICAgIGVtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaSA9IHRoaXMubGVuZ3RoXG4gICAgICB2YXIgZWxlbWVudFxuICAgICAgd2hpbGUgKGkpIHtcbiAgICAgICAgaSAtPSAxXG4gICAgICAgIGVsZW1lbnQgPSB0aGlzW2ldXG4gICAgICAgIHdoaWxlIChlbGVtZW50Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQoZWxlbWVudC5sYXN0Q2hpbGQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcblxuICAgIGZpcnN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IEhlbHBlcih0aGlzWzBdKVxuICAgIH1cbiAgfSlcblxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBIZWxwZXJcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5ibHVlaW1wID0gd2luZG93LmJsdWVpbXAgfHwge31cbiAgICB3aW5kb3cuYmx1ZWltcC5oZWxwZXIgPSBIZWxwZXJcbiAgfVxufSkoKVxuIiwiXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmYWN0b3J5KTtcbiAgfSBlbHNlIHtcbiAgICByb290LmdldFlvdVR1YmVJRCA9IGZhY3RvcnkoKTtcbiAgfVxufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykge1xuXG4gIHJldHVybiBmdW5jdGlvbiAodXJsLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgPT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRzID0ge2Z1enp5OiB0cnVlfTtcbiAgICB9XG5cbiAgICBpZiAoL3lvdXR1XFwuP2JlLy50ZXN0KHVybCkpIHtcblxuICAgICAgLy8gTG9vayBmaXJzdCBmb3Iga25vd24gcGF0dGVybnNcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIHBhdHRlcm5zID0gW1xuICAgICAgICAveW91dHVcXC5iZVxcLyhbXiNcXCZcXD9dezExfSkvLCAgLy8geW91dHUuYmUvPGlkPlxuICAgICAgICAvXFw/dj0oW14jXFwmXFw/XXsxMX0pLywgICAgICAgICAvLyA/dj08aWQ+XG4gICAgICAgIC9cXCZ2PShbXiNcXCZcXD9dezExfSkvLCAgICAgICAgIC8vICZ2PTxpZD5cbiAgICAgICAgL2VtYmVkXFwvKFteI1xcJlxcP117MTF9KS8sICAgICAgLy8gZW1iZWQvPGlkPlxuICAgICAgICAvXFwvdlxcLyhbXiNcXCZcXD9dezExfSkvICAgICAgICAgLy8gL3YvPGlkPlxuICAgICAgXTtcblxuICAgICAgLy8gSWYgYW55IHBhdHRlcm4gbWF0Y2hlcywgcmV0dXJuIHRoZSBJRFxuICAgICAgZm9yIChpID0gMDsgaSA8IHBhdHRlcm5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChwYXR0ZXJuc1tpXS50ZXN0KHVybCkpIHtcbiAgICAgICAgICByZXR1cm4gcGF0dGVybnNbaV0uZXhlYyh1cmwpWzFdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRzLmZ1enp5KSB7XG4gICAgICAgIC8vIElmIHRoYXQgZmFpbHMsIGJyZWFrIGl0IGFwYXJ0IGJ5IGNlcnRhaW4gY2hhcmFjdGVycyBhbmQgbG9vayBcbiAgICAgICAgLy8gZm9yIHRoZSAxMSBjaGFyYWN0ZXIga2V5XG4gICAgICAgIHZhciB0b2tlbnMgPSB1cmwuc3BsaXQoL1tcXC9cXCZcXD89I1xcLlxcc10vZyk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAoL15bXiNcXCZcXD9dezExfSQvLnRlc3QodG9rZW5zW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRva2Vuc1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxufSkpO1xuIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ2JsdWVpbXAtZ2FsbGVyeS9jc3MvYmx1ZWltcC1nYWxsZXJ5Lm1pbi5jc3MnKSwgcmVxdWlyZSgnYmx1ZWltcC1nYWxsZXJ5L2pzL2JsdWVpbXAtZ2FsbGVyeS1mdWxsc2NyZWVuLmpzJyksIHJlcXVpcmUoJ2JsdWVpbXAtZ2FsbGVyeS9qcy9ibHVlaW1wLWdhbGxlcnktdmlkZW8uanMnKSwgcmVxdWlyZSgnYmx1ZWltcC1nYWxsZXJ5L2pzL2JsdWVpbXAtZ2FsbGVyeS15b3V0dWJlLmpzJyksIHJlcXVpcmUoJ2JsdWVpbXAtZ2FsbGVyeS9qcy9ibHVlaW1wLWdhbGxlcnkuanMnKSkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydibHVlaW1wLWdhbGxlcnkvY3NzL2JsdWVpbXAtZ2FsbGVyeS5taW4uY3NzJywgJ2JsdWVpbXAtZ2FsbGVyeS9qcy9ibHVlaW1wLWdhbGxlcnktZnVsbHNjcmVlbi5qcycsICdibHVlaW1wLWdhbGxlcnkvanMvYmx1ZWltcC1nYWxsZXJ5LXZpZGVvLmpzJywgJ2JsdWVpbXAtZ2FsbGVyeS9qcy9ibHVlaW1wLWdhbGxlcnkteW91dHViZS5qcycsICdibHVlaW1wLWdhbGxlcnkvanMvYmx1ZWltcC1nYWxsZXJ5LmpzJ10sIGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuVnVlR2FsbGVyeSA9IGZhY3RvcnkobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgZ2xvYmFsLmJsdWVpbXApKTtcbn0odGhpcywgZnVuY3Rpb24gKGJsdWVpbXBHYWxsZXJ5X21pbl9jc3MsIGJsdWVpbXBHYWxsZXJ5RnVsbHNjcmVlbl9qcywgYmx1ZWltcEdhbGxlcnlWaWRlb19qcywgYmx1ZWltcEdhbGxlcnlZb3V0dWJlX2pzLCBibHVlaW1wKSB7ICd1c2Ugc3RyaWN0JztcblxuICBibHVlaW1wID0gYmx1ZWltcCAmJiBibHVlaW1wLmhhc093blByb3BlcnR5KCdkZWZhdWx0JykgPyBibHVlaW1wWydkZWZhdWx0J10gOiBibHVlaW1wO1xuXG4gIC8vXG4gIHZhciBzY3JpcHQgPSB7XG4gICAgcHJvcHM6IHtcbiAgICAgIGltYWdlczoge1xuICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhcm91c2VsOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgaW5kZXg6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyXG4gICAgICB9LFxuICAgICAgaWQ6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiAnYmx1ZWltcC1nYWxsZXJ5J1xuICAgICAgfVxuICAgIH0sXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluc3RhbmNlOiBudWxsXG4gICAgICB9O1xuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgIGluZGV4OiBmdW5jdGlvbiBpbmRleCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5jYXJvdXNlbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMub3Blbih2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UuY2xvc2UoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLiRlbWl0KCdjbG9zZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgICAgaWYgKHRoaXMuY2Fyb3VzZWwpIHtcbiAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCgpIHtcbiAgICAgIGlmICh0aGlzLmluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UuZGVzdHJveUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICBvcGVuOiBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBpbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gdHlwZW9mIGJsdWVpbXAuR2FsbGVyeSAhPT0gJ3VuZGVmaW5lZCcgPyBibHVlaW1wLkdhbGxlcnkgOiBibHVlaW1wO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIHRvZ2dsZUNvbnRyb2xzT25SZXR1cm46IGZhbHNlLFxuICAgICAgICAgIHRvZ2dsZUNvbnRyb2xzT25TbGlkZUNsaWNrOiBmYWxzZSxcbiAgICAgICAgICBjbG9zZU9uU2xpZGVDbGljazogZmFsc2UsXG4gICAgICAgICAgY2Fyb3VzZWw6IHRoaXMuY2Fyb3VzZWwsXG4gICAgICAgICAgY29udGFpbmVyOiBcIiNcIi5jb25jYXQodGhpcy5pZCksXG4gICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgIG9ub3BlbjogZnVuY3Rpb24gb25vcGVuKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLiRlbWl0KCdvbm9wZW4nKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9ub3BlbmVkOiBmdW5jdGlvbiBvbm9wZW5lZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy4kZW1pdCgnb25vcGVuZWQnKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uc2xpZGU6IHRoaXMub25TbGlkZUN1c3RvbSxcbiAgICAgICAgICBvbnNsaWRlZW5kOiBmdW5jdGlvbiBvbnNsaWRlZW5kKGluZGV4LCBzbGlkZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLiRlbWl0KCdvbnNsaWRlZW5kJywge1xuICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgIHNsaWRlOiBzbGlkZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbnNsaWRlY29tcGxldGU6IGZ1bmN0aW9uIG9uc2xpZGVjb21wbGV0ZShpbmRleCwgc2xpZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy4kZW1pdCgnb25zbGlkZWNvbXBsZXRlJywge1xuICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgIHNsaWRlOiBzbGlkZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbmNsb3NlOiBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLiRlbWl0KCdjbG9zZScpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25jbG9zZWQ6IGZ1bmN0aW9uIG9uY2xvc2VkKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLiRlbWl0KCdvbmNsb3NlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5vcHRpb25zKTtcblxuICAgICAgICBpZiAodGhpcy5jYXJvdXNlbCkge1xuICAgICAgICAgIG9wdGlvbnMuY29udGFpbmVyID0gdGhpcy4kZWw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmluc3RhbmNlID0gaW5zdGFuY2UodGhpcy5pbWFnZXMsIG9wdGlvbnMpO1xuICAgICAgfSxcbiAgICAgIG9uU2xpZGVDdXN0b206IGZ1bmN0aW9uIG9uU2xpZGVDdXN0b20oaW5kZXgsIHNsaWRlKSB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ29uc2xpZGUnLCB7XG4gICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgIHNsaWRlOiBzbGlkZVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGltYWdlID0gdGhpcy5pbWFnZXNbaW5kZXhdO1xuXG4gICAgICAgIGlmIChpbWFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIHRleHQgPSBpbWFnZS5kZXNjcmlwdGlvbjtcbiAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuaW5zdGFuY2UuY29udGFpbmVyLmZpbmQoJy5kZXNjcmlwdGlvbicpO1xuXG4gICAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgIG5vZGUuZW1wdHkoKTtcbiAgICAgICAgICAgIG5vZGVbMF0uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnQodGVtcGxhdGUsIHN0eWxlLCBzY3JpcHQsIHNjb3BlSWQsIGlzRnVuY3Rpb25hbFRlbXBsYXRlLCBtb2R1bGVJZGVudGlmaWVyXG4gIC8qIHNlcnZlciBvbmx5ICovXG4gICwgc2hhZG93TW9kZSwgY3JlYXRlSW5qZWN0b3IsIGNyZWF0ZUluamVjdG9yU1NSLCBjcmVhdGVJbmplY3RvclNoYWRvdykge1xuICAgIGlmICh0eXBlb2Ygc2hhZG93TW9kZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBjcmVhdGVJbmplY3RvclNTUiA9IGNyZWF0ZUluamVjdG9yO1xuICAgICAgY3JlYXRlSW5qZWN0b3IgPSBzaGFkb3dNb2RlO1xuICAgICAgc2hhZG93TW9kZSA9IGZhbHNlO1xuICAgIH0gLy8gVnVlLmV4dGVuZCBjb25zdHJ1Y3RvciBleHBvcnQgaW50ZXJvcC5cblxuXG4gICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0ID09PSAnZnVuY3Rpb24nID8gc2NyaXB0Lm9wdGlvbnMgOiBzY3JpcHQ7IC8vIHJlbmRlciBmdW5jdGlvbnNcblxuICAgIGlmICh0ZW1wbGF0ZSAmJiB0ZW1wbGF0ZS5yZW5kZXIpIHtcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gdGVtcGxhdGUucmVuZGVyO1xuICAgICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSB0ZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG4gICAgICBvcHRpb25zLl9jb21waWxlZCA9IHRydWU7IC8vIGZ1bmN0aW9uYWwgdGVtcGxhdGVcblxuICAgICAgaWYgKGlzRnVuY3Rpb25hbFRlbXBsYXRlKSB7XG4gICAgICAgIG9wdGlvbnMuZnVuY3Rpb25hbCA9IHRydWU7XG4gICAgICB9XG4gICAgfSAvLyBzY29wZWRJZFxuXG5cbiAgICBpZiAoc2NvcGVJZCkge1xuICAgICAgb3B0aW9ucy5fc2NvcGVJZCA9IHNjb3BlSWQ7XG4gICAgfVxuXG4gICAgdmFyIGhvb2s7XG5cbiAgICBpZiAobW9kdWxlSWRlbnRpZmllcikge1xuICAgICAgLy8gc2VydmVyIGJ1aWxkXG4gICAgICBob29rID0gZnVuY3Rpb24gaG9vayhjb250ZXh0KSB7XG4gICAgICAgIC8vIDIuMyBpbmplY3Rpb25cbiAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgLy8gY2FjaGVkIGNhbGxcbiAgICAgICAgdGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dCB8fCAvLyBzdGF0ZWZ1bFxuICAgICAgICB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC4kdm5vZGUgJiYgdGhpcy5wYXJlbnQuJHZub2RlLnNzckNvbnRleHQ7IC8vIGZ1bmN0aW9uYWxcbiAgICAgICAgLy8gMi4yIHdpdGggcnVuSW5OZXdDb250ZXh0OiB0cnVlXG5cbiAgICAgICAgaWYgKCFjb250ZXh0ICYmIHR5cGVvZiBfX1ZVRV9TU1JfQ09OVEVYVF9fICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGNvbnRleHQgPSBfX1ZVRV9TU1JfQ09OVEVYVF9fO1xuICAgICAgICB9IC8vIGluamVjdCBjb21wb25lbnQgc3R5bGVzXG5cblxuICAgICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgICBzdHlsZS5jYWxsKHRoaXMsIGNyZWF0ZUluamVjdG9yU1NSKGNvbnRleHQpKTtcbiAgICAgICAgfSAvLyByZWdpc3RlciBjb21wb25lbnQgbW9kdWxlIGlkZW50aWZpZXIgZm9yIGFzeW5jIGNodW5rIGluZmVyZW5jZVxuXG5cbiAgICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMpIHtcbiAgICAgICAgICBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cy5hZGQobW9kdWxlSWRlbnRpZmllcik7XG4gICAgICAgIH1cbiAgICAgIH07IC8vIHVzZWQgYnkgc3NyIGluIGNhc2UgY29tcG9uZW50IGlzIGNhY2hlZCBhbmQgYmVmb3JlQ3JlYXRlXG4gICAgICAvLyBuZXZlciBnZXRzIGNhbGxlZFxuXG5cbiAgICAgIG9wdGlvbnMuX3NzclJlZ2lzdGVyID0gaG9vaztcbiAgICB9IGVsc2UgaWYgKHN0eWxlKSB7XG4gICAgICBob29rID0gc2hhZG93TW9kZSA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3R5bGUuY2FsbCh0aGlzLCBjcmVhdGVJbmplY3RvclNoYWRvdyh0aGlzLiRyb290LiRvcHRpb25zLnNoYWRvd1Jvb3QpKTtcbiAgICAgIH0gOiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBzdHlsZS5jYWxsKHRoaXMsIGNyZWF0ZUluamVjdG9yKGNvbnRleHQpKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGhvb2spIHtcbiAgICAgIGlmIChvcHRpb25zLmZ1bmN0aW9uYWwpIHtcbiAgICAgICAgLy8gcmVnaXN0ZXIgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IGluIHZ1ZSBmaWxlXG4gICAgICAgIHZhciBvcmlnaW5hbFJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuXG4gICAgICAgIG9wdGlvbnMucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyV2l0aFN0eWxlSW5qZWN0aW9uKGgsIGNvbnRleHQpIHtcbiAgICAgICAgICBob29rLmNhbGwoY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVuZGVyKGgsIGNvbnRleHQpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCByZWdpc3RyYXRpb24gYXMgYmVmb3JlQ3JlYXRlIGhvb2tcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gb3B0aW9ucy5iZWZvcmVDcmVhdGU7XG4gICAgICAgIG9wdGlvbnMuYmVmb3JlQ3JlYXRlID0gZXhpc3RpbmcgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGhvb2spIDogW2hvb2tdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzY3JpcHQ7XG4gIH1cblxuICB2YXIgbm9ybWFsaXplQ29tcG9uZW50XzEgPSBub3JtYWxpemVDb21wb25lbnQ7XG5cbiAgdmFyIGlzT2xkSUUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvbXNpZSBbNi05XVxcXFxiLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5qZWN0b3IoY29udGV4dCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaWQsIHN0eWxlKSB7XG4gICAgICByZXR1cm4gYWRkU3R5bGUoaWQsIHN0eWxlKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIEhFQUQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gIHZhciBzdHlsZXMgPSB7fTtcblxuICBmdW5jdGlvbiBhZGRTdHlsZShpZCwgY3NzKSB7XG4gICAgdmFyIGdyb3VwID0gaXNPbGRJRSA/IGNzcy5tZWRpYSB8fCAnZGVmYXVsdCcgOiBpZDtcbiAgICB2YXIgc3R5bGUgPSBzdHlsZXNbZ3JvdXBdIHx8IChzdHlsZXNbZ3JvdXBdID0ge1xuICAgICAgaWRzOiBuZXcgU2V0KCksXG4gICAgICBzdHlsZXM6IFtdXG4gICAgfSk7XG5cbiAgICBpZiAoIXN0eWxlLmlkcy5oYXMoaWQpKSB7XG4gICAgICBzdHlsZS5pZHMuYWRkKGlkKTtcbiAgICAgIHZhciBjb2RlID0gY3NzLnNvdXJjZTtcblxuICAgICAgaWYgKGNzcy5tYXApIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9kZXZ0b29scy9kb2NzL2phdmFzY3JpcHQtZGVidWdnaW5nXG4gICAgICAgIC8vIHRoaXMgbWFrZXMgc291cmNlIG1hcHMgaW5zaWRlIHN0eWxlIHRhZ3Mgd29yayBwcm9wZXJseSBpbiBDaHJvbWVcbiAgICAgICAgY29kZSArPSAnXFxuLyojIHNvdXJjZVVSTD0nICsgY3NzLm1hcC5zb3VyY2VzWzBdICsgJyAqLyc7IC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cbiAgICAgICAgY29kZSArPSAnXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCwnICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoY3NzLm1hcCkpKSkgKyAnICovJztcbiAgICAgIH1cblxuICAgICAgaWYgKCFzdHlsZS5lbGVtZW50KSB7XG4gICAgICAgIHN0eWxlLmVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICBzdHlsZS5lbGVtZW50LnR5cGUgPSAndGV4dC9jc3MnO1xuICAgICAgICBpZiAoY3NzLm1lZGlhKSBzdHlsZS5lbGVtZW50LnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBjc3MubWVkaWEpO1xuICAgICAgICBIRUFELmFwcGVuZENoaWxkKHN0eWxlLmVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoJ3N0eWxlU2hlZXQnIGluIHN0eWxlLmVsZW1lbnQpIHtcbiAgICAgICAgc3R5bGUuc3R5bGVzLnB1c2goY29kZSk7XG4gICAgICAgIHN0eWxlLmVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gc3R5bGUuc3R5bGVzLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpbmRleCA9IHN0eWxlLmlkcy5zaXplIC0gMTtcbiAgICAgICAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY29kZSk7XG4gICAgICAgIHZhciBub2RlcyA9IHN0eWxlLmVsZW1lbnQuY2hpbGROb2RlcztcbiAgICAgICAgaWYgKG5vZGVzW2luZGV4XSkgc3R5bGUuZWxlbWVudC5yZW1vdmVDaGlsZChub2Rlc1tpbmRleF0pO1xuICAgICAgICBpZiAobm9kZXMubGVuZ3RoKSBzdHlsZS5lbGVtZW50Lmluc2VydEJlZm9yZSh0ZXh0Tm9kZSwgbm9kZXNbaW5kZXhdKTtlbHNlIHN0eWxlLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGV4dE5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBicm93c2VyID0gY3JlYXRlSW5qZWN0b3I7XG5cbiAgLyogc2NyaXB0ICovXG4gIGNvbnN0IF9fdnVlX3NjcmlwdF9fID0gc2NyaXB0O1xuXG4gIC8qIHRlbXBsYXRlICovXG4gIHZhciBfX3Z1ZV9yZW5kZXJfXyA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiYmx1ZWltcC1nYWxsZXJ5IGJsdWVpbXAtZ2FsbGVyeS1jb250cm9sc1wiLGNsYXNzOnsnYmx1ZWltcC1nYWxsZXJ5LWNhcm91c2VsJzogX3ZtLmNhcm91c2VsfSxhdHRyczp7XCJpZFwiOl92bS5pZH19LFtfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJzbGlkZXNcIn0pLF92bS5fdihcIiBcIiksX2MoJ2gzJyx7c3RhdGljQ2xhc3M6XCJ0aXRsZVwifSksX3ZtLl92KFwiIFwiKSxfYygncCcse3N0YXRpY0NsYXNzOlwiZGVzY3JpcHRpb25cIn0pLF92bS5fdihcIiBcIiksX2MoJ2EnLHtzdGF0aWNDbGFzczpcInByZXZcIn0sW192bS5fdChcInByZXZcIixbX3ZtLl92KFwi4oC5XCIpXSldLDIpLF92bS5fdihcIiBcIiksX2MoJ2EnLHtzdGF0aWNDbGFzczpcIm5leHRcIn0sW192bS5fdChcIm5leHRcIixbX3ZtLl92KFwi4oC6XCIpXSldLDIpLF92bS5fdihcIiBcIiksKCFfdm0uY2Fyb3VzZWwpP19jKCdhJyx7c3RhdGljQ2xhc3M6XCJjbG9zZVwifSxbX3ZtLl90KFwiY2xvc2VcIixbX3ZtLl92KFwiw5dcIildKV0sMik6X3ZtLl9lKCksX3ZtLl92KFwiIFwiKSwoIV92bS5jYXJvdXNlbCk/X2MoJ29sJyx7c3RhdGljQ2xhc3M6XCJpbmRpY2F0b3JcIn0pOl92bS5fZSgpLF92bS5fdihcIiBcIiksKF92bS5jYXJvdXNlbCk/X2MoJ2EnLHtzdGF0aWNDbGFzczpcInBsYXktcGF1c2VcIn0pOl92bS5fZSgpXSl9O1xuICB2YXIgX192dWVfc3RhdGljUmVuZGVyRm5zX18gPSBbXTtcblxuICAgIC8qIHN0eWxlICovXG4gICAgY29uc3QgX192dWVfaW5qZWN0X3N0eWxlc19fID0gZnVuY3Rpb24gKGluamVjdCkge1xuICAgICAgaWYgKCFpbmplY3QpIHJldHVyblxuICAgICAgaW5qZWN0KFwiZGF0YS12LTZkMjAzM2JhXzBcIiwgeyBzb3VyY2U6IFwiLmJsdWVpbXAtZ2FsbGVyeT4uZGVzY3JpcHRpb257cG9zaXRpb246YWJzb2x1dGU7dG9wOjMwcHg7bGVmdDoxNXB4O2NvbG9yOiNmZmY7ZGlzcGxheTpub25lfS5ibHVlaW1wLWdhbGxlcnktY29udHJvbHM+LmRlc2NyaXB0aW9ue2Rpc3BsYXk6YmxvY2t9XCIsIG1hcDogdW5kZWZpbmVkLCBtZWRpYTogdW5kZWZpbmVkIH0pO1xuXG4gICAgfTtcbiAgICAvKiBzY29wZWQgKi9cbiAgICBjb25zdCBfX3Z1ZV9zY29wZV9pZF9fID0gdW5kZWZpbmVkO1xuICAgIC8qIG1vZHVsZSBpZGVudGlmaWVyICovXG4gICAgY29uc3QgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IHVuZGVmaW5lZDtcbiAgICAvKiBmdW5jdGlvbmFsIHRlbXBsYXRlICovXG4gICAgY29uc3QgX192dWVfaXNfZnVuY3Rpb25hbF90ZW1wbGF0ZV9fID0gZmFsc2U7XG4gICAgLyogc3R5bGUgaW5qZWN0IFNTUiAqL1xuICAgIFxuXG4gICAgXG4gICAgdmFyIFZ1ZUdhbGxlcnkgPSBub3JtYWxpemVDb21wb25lbnRfMShcbiAgICAgIHsgcmVuZGVyOiBfX3Z1ZV9yZW5kZXJfXywgc3RhdGljUmVuZGVyRm5zOiBfX3Z1ZV9zdGF0aWNSZW5kZXJGbnNfXyB9LFxuICAgICAgX192dWVfaW5qZWN0X3N0eWxlc19fLFxuICAgICAgX192dWVfc2NyaXB0X18sXG4gICAgICBfX3Z1ZV9zY29wZV9pZF9fLFxuICAgICAgX192dWVfaXNfZnVuY3Rpb25hbF90ZW1wbGF0ZV9fLFxuICAgICAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyxcbiAgICAgIGJyb3dzZXIsXG4gICAgICB1bmRlZmluZWRcbiAgICApO1xuXG4gIHJldHVybiBWdWVHYWxsZXJ5O1xuXG59KSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=